\section{Tree shaking}

Tree Shaking bedeutet im Javascript Umfeld Dead-Code Elimination. Der Begriff und das dahinterliegende Konzept wurde durch den ES2015 Modul Bundler Rollup populär. Das Konzept des Tree Shaking beruht auf der statischen Struktur von ES6 Modulen. Diese werden im Zusammenhang mit Bundlern wie Webpack oder RollupJS oft auch als Pure Modules oder Modules oder Harmony Modules bezeichnet. \autocite{WebpackTreeShaking}

Wie bereits im Kapitel \ref{section:modules_in_javaScript} gezeigt wurde, ermöglicht die ES6 Spezifikation, sowohl die statische Analyse von Modulen, als auch die Verwendung einer Teilmenge der zur Verfügung gestellten Exporte.
Für das nachfolgende Beispiel wurde Webpack verwendet.

\begin{lstlisting}[
    label=listing:treeshacking_helpers,
	caption=helpers.js,
	language=JavaScript
]
export function hello() {
  return 'hello';
}
export function world() {
  return 'world';
}

export default {
  hello,
  world
}
\end{lstlisting}

\begin{lstlisting}[
    label=listing:treeshacking_index,
	caption=index.js,
	language=JavaScript
]
import {hello} from './helpers';

let elem = document.getElementById('output');
elem.innerHTML = `Output: ${hello()}`;
\end{lstlisting}

Listing \ref{listing:treeshacking_index} zeigt die Verwendung des zuvor Implementierten \lstinline{helpers.js} Moduls. Dabei ist zu beachten das die lediglich die Methode \lstinline{hello} importiert und verwendet wird. \lstinline{world} gilt somit als Dead Code oder Unused Export und wird in der gebündelten Anwendung nicht benötigt.

Damit Webpack

\begin{lstlisting}[
    label=listing:treeshacking_bundle,
	caption=bundle.js,
	language=JavaScript,
    firstnumber=79
]
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = hello;
/* unused harmony export world */
function hello() {
  return 'hello';
}
function world() {
  return 'world';
}

/* unused harmony default export */ var _unused_webpack_default_export = ({
  hello: hello,
  world: world
});
\end{lstlisting}

Um die unnötigne Codezeilen zu entfernen werden diese zuerst von Webpack makiert. In Listing \ref{listing:treeshacking_bundle} wurde, sowohl der Default Export, als auch die \lstinline{world} Funktion mit \lstinline{unused harmony} makiert.

Webpack entfernt den unerwünschten Code nicht, erst der darauf folgenden Minifier erkennt die \lstinline{unused harmony} Annotationen und entfernt diese Segmente.

Die daraus resultierende Bundle Datei beinhaltet eine stark verkleinerte \lstinline{hello} Funktion und die nicht benötigte Methode \lstinline{world} wurde aus der Datei entfernt. Auch wenn in diesem Beispiel der Gewinn nicht groß ist, kann Tree Shaking dazu beitragen die Bundle Datei in größeren Projekte signifikant zu verkleinern.
\autocite{WebpackTreeShaking}

\subsection{Webpack}

Um Tree Shaking mit Webpack zu ermöglichen sind einige Konfigurationen nötig. 
Zuvor ist es wichtig einen genaueren Blick darauf zu werfen wie Webpack mit ES6 Modulen arbeitet.

Eine große Schwierigkeit bei der Verwendung von ES6 ist die Browser Inkompatibilität. Erstens dauert es eine gewisse Zeit bis die neuen Spezifikationen in den Browsern von den Herstellern implementiert werden können \autocite{CanIUseES6}. Zweitens benutzt ein beachtlicher Teil der Clients nicht die aktuellste verfügbare Version \autocite{CanIUseUsageTable}.

Um das Problem mit der Inkompatibilität zu umgehen werden JavaScript Compiler wie Babel verwendet. Diese verwandeln Es6 in einen für die meisten Browser Kompatiblen JavaScript Code. Somit können Entwickler und Entwicklerinnen bereits die neusten Funktionen verwenden ,ohne das diese von dem Großteil der Browser unterstützt werden muss.\autocite{Babel}

Per Default wird von Babel jedes JavaScript Modul in CommonJS konvertiert. Durch die dynamische Implementierung von CommonJS Modulen können diese jedoch nicht statisch Analysiert werden. Es ist daher entscheidend um ein erfolgreiches Tree Shaking zu ermöglichen, dies zu ändern.\autocite{Babel}

\begin{lstlisting}[
    label=listing:treeshacking_config,
	caption=webpack.config.js,
	language=JavaScript,
]
{
  entry: './index.js',
  output: {
    filename: 'dist/es6-modules/bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        query: {
          presets: [
            ['es2015', { modules: false }]
          ]
        }
      }
    ]
  }
}
});
\end{lstlisting}

Listing \ref{listing:treeshacking_config} zeigt eine typische Tree Shaking Konfiguration von Babel und Webpack. Besonders wichtig ist der \lstinline{modules: false} Flag von Babel. Mit dieser kann man die automatische Modul Transformationen verändern. Neben dem \lstinline{false} Wert der diese komplett deaktiviert, ist es ebenfalls möglich andere Optionen anzugeben (\lstinline{"amd" | "umd" | "systemjs" | "commonjs"}). \autocite{Babel}

\subsection{RollupJS}
Neben Webpack wurde das Tree shaking Konzept vor allem durch den ES6 Module Bundler RollupJS bekannt \autocite{WebpackTreeShaking}. Dieser wird vor allem empfohlen beim Entwickeln von Libaries. Webpack wiederum bietet eine bessere Unterstützung für Assets wie Bilder oder CSS und gilt daher als besseres geeignet für die Erstellung von Apps. \autocite{RichHarris}

Der Unterschied zwischen den Bundlern liegt in der Art und weise wie die einzelnen Module im Bundle File verpackt sind. Webpack hüllt jedes Modul in eine Funktion mit einer browser-freundlichen Implementierung von \lstinline{require} \autocite{RichHarris}. Features wie On-demand Loading werden dadurch erst möglich. \textcite{NolanLawson} konnte jedoch zeigen das dies im weiteren auch dazu führt, dass je mehr Module verwendet werden auch der damit einhergehende Overhead wächst.

RollupJS verwendet im Gegensatz die Möglichkeiten von ES6. Der gesamte Code landet an einem Platz und wird in einem Durchgang verarbeitet. Damit wird der Code schlanker und kann schneller starten. \autocite{RichHarris}

\subsection{Hindernisse}
\label{section:schwierigkeiten_beim_tree_shaking}
In dieser Arbeit wird Tree Shaking aus der Perspektive zweier Entwicklergruppen betrachtet. 

Zum einen jene Entwickler und Entwicklerinnen welche viel projektinternen JavaScript Code in ihren Webpack Projekten verwenden. Ihr Ziel ist es eine oder mehrere möglichst kleiner Bundle Dateien an den Client auszuliefern, für schnelle Seitenaufrufe und eine angenehmes Benutzererlebnis.

Die zweite Gruppe ist jene der Javascript Libary und Framework Entwickler. Ihr Sourcecode wird von vielen Projekten in verschiedener Art und Weise verwendet. In vielen Fällen wird in den Javascript Projekten nur ein kleiner klein der importierten Libaries verwendet. Wenn diese Tree Shaking unterstützt, können jedoch Bundler wie Webpack, den unnötig Code beim kompilieren der Bundle Datei entfernen.

In diesem Kapitel werden meherere Hindernisse für die beiden Benutzergruppen veranschaulicht und in weitere Folge Maßnahmen zu Vermeidung dieser ermittelt. 

(http://www.syntaxsuccess.com/viewarticle/tree-shaking-with-webpack)

\subsubsection{Richtiges Importieren und Exportieren}

Wie bereits in den Kapitel \ref{subsubsection:default_exports} und \ref{subsubsection:named_exports} beschrieben können Javascript Module mittels Namend oder Default Export

nicht
	import Test from 'module1'
    Test.func1()
besser 
	import {func1} from 'module1'

\subsubsection{Exportieren}
keine default exporte ?

alles was importiert wird sollte auch exportiert werden (stimmt nicht ganz es können sideeffects enthalten sein sideeffect: [*.css])

\subsubsection{Side Effects}
\label{subsubsection:side_effects}
Umfangreiche und weitverbreitete JavaScript Libaries wie zum Beispiel Lodash\footnote{https://lodash.com/ - besucht am 26.05.2018} und jQuery\footnote{https://jquery.com/ - besucht am 26.05.2018} bieten eine große Anzahl an nützlichen Tools. Sie werden meistens als NPM Modul installiert und anschließend in den Projektdateien als Import eingebunden. Zu meist werden nur Teile von den zu Verfügung gestellten Funktionalitäten auch wirklich verwendet. Das kann dazuführen das ein erheblich Teil der von Webpack erzeugten Bundledatei aus nicht benötigten Code besteht. Plugins wie der Webpack Visualizer bieten eine einfache Möglichkeit, um festzustellen, welche Module in der von Webpack generierten Bundle Datei am meisten Speicherplatz einnehmen.

Jedoch bietet unter anderem Webpack eine Möglichkeit für Libary Entwickler und Entwicklerinnen diese so zu Implementieren ,dass der nicht benötigte Libary Sourcecode beim builden entfernt wird.
Durch die Verwendung von \lstinline{sideEffects: false} in der package.json Datei innerhalb der Libary, wird Webpack mitgeteilt das Tree Shaking nicht nur auf den üblichen Projektcode anzuwenden, sondern ebenfalls auf den Code der sich im Libary Ordner befindet.

Dabei werden Importdeklarationen wie \lstinline|import {a, b} from "big-module-with-flag"| von Webpack erkannt und beim Bau der Applikation zu \lstinline|import a from "big-module-with-flag/a" import b from "big-module-with-flag/b"| umgeschrieben. Somit werden in der Bundle Datei auch nur die zwei von dem Entwickler oder der Entwicklerin verwendeten Methoden importiert und der restliche Libary Code entfernt \autocite{WebpackTreeShaking}.Zur Veranschaulichung dient ein ausführlich dokumentiertes Beispiel\footnote{https://github.com/webpack/webpack/tree/master/examples/side-effects - besucht am 26.05.2018}. 

Wenn mit Hilfe von \lstinline{sideEffects: false} ein Modul als Rein bezeichnet wird, werden alle nicht verwendeten Methoden, Klassen oder Objekte aus dem Code entfernt. Dies kann jedoch die Funktionsweise erheblich stören. Side Effects sind somit Code Segmente, welche beim Tree Shaking nicht entfernt werden dürfen. Dies möchte ich mittels eines Beispiels näher erläutern.

\begin{lstlisting}[
    label=listing:sideeffects,
	caption=webpack.config.js,
	language=JavaScript,
]
	import a from 'a'
    import b from 'b'
    
    console.log("das ist ein sideeffect")
    
    export default {
    	a,
        b
    }
\end{lstlisting}





-------------BSP von webpack------------------

-vorallem wichtig für libary entwickler
-was sind sideeffects?
-wie schaut eine übliche sideeffect freie libary aus?
-Aus den ES Specs wurden folgende AST Nodes ermittelt (ImportDeclaration, ExportNamedDeclaration, ExportDefaultDeclaration)
-des weiteren muss jeder import auch exportiert werden
-kann auch ein array von files angegeben werden (diese besitzen sideeffects)

\autocite{TamasSallai}

