\section{Modules in JavaScript}
\label{section:modules_in_javaScript}
In traditionellen JavaScript Webprojekten werden alle Abhängigkeiten als Liste aus \lstinline{<script>} tags definiert. Es ist die Aufgabe des Entwicklers oder der Entwicklerin sicherzustellen das diese in der richtigen Reihenfolge zur Verfügung gestellt werden. Je komplexer die Abhängigkeiten zwischen dem  Programmcode, Frameworks und Libaries werden, desto schwieriger wird die Wartung und die richtige Platzierung neuer Einträge in der richtigen Reihenfolge. Es wurden bereits mit verschiedenen Modul Spezifikationen versucht diese Schwierigkeiten für Entwickler und Entwicklerinnen zu vereinfachen. \autocite{SebastianPeyrott}

\subsection{CommonJS}
Das Ziel von CommonJS ist eine Modul Spezifikation zur Erleichterung der Entwicklung von Serverseitigen JavaScript Anwendungen.NodeJS Entwickler verfolgte anfangs diesen Ansatz, entschieden sich im späteren Verlauf jedoch dagegen. Dennoch wurde die Implementierung stark von der CommonJS Spezifikation beeinflusst. \autocite{SebastianPeyrott}

\begin{lstlisting}[
    label=listing:commonjs,
	caption=CommonJS Module,
	language=JavaScript
]
// In circle.js
const PI = Math.PI;

exports.area = (r) => PI * r * r;

exports.circumference = (r) => 2 * PI * r;

// In some file
const circle = require('./circle.js');
console.log( `The area of a circle of radius 4 is ${circle.area(4)}`);
\end{lstlisting}

Sowohl bei CommonJS als auch bei der NodeJS Implementierung gibt es zwei Elemente um mit dem Modul System zu interagieren: \lstinline{require} und \lstinline{exports}. \lstinline{require} wird benötigt um ein anderes Modul in den aktuellen Scope zu importieren. Dabei wird als Parameter die Modul-id angegeben. Diese ist entweder der Name des Moduls innerhalb des \lstinline{node_modules} Ordner oder der gesamte Pfad. \lstinline{exports} dient zur Definition einer Modul Schnittstelle. Jede Property des \lstinline{exports} Objekts wird als öffentliches Element exportiert. Der Unterschied zwischen NodeJS und CommonJS liegt vorallem im \lstinline{module.exports} Objekt. Dies erfüllt die selbe Aufgabe wie bei CommonJS das \lstinline{exports} Objekt. Abschließend bleibt zu erwähnen das die Module synchron geladen werden. Sprich in dem Moment und in der Reihnfolge in der sie mit \lstinline{require} angegeben wurden.\autocite{SebastianPeyrott}

\subsection{Asynchronous Model Definition (AMD)}

Das Entwickler Team von AMD spaltete sich wärend der Entwicklung von CommonJS ab. Der Haupt Unterschied zwischen diese beiden Systemen liegt in dem asynchronen laden von Ressourcen. \autocite{SebastianPeyrott}

\begin{lstlisting}[
    label=listing:amd,
	caption=Asynchronous Model Definition,
	language=JavaScript
]
//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
});

// Or:
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');

    return function () {};
});
\end{lstlisting}

Das asynchrone Laden wird ermöglicht durch einen Funktionsaufruf nach dem anfordern der  Abhängigkeiten. Libaries die nicht voneinander abhängig sind können somit zur selben Zeit geladen werden. Dies ist besonders wichtig für die Frontend Entwicklung, da dort die Startzeit einer Anwendung essenziell für ein gutes Benutzererlebnis ist. \autocite{SebastianPeyrott}

\subsection{ECMAScript 6}
Ziel der ECMAScript 6 Modules war es ein Format zu kreieren, welches sowohl AMD, als auch CommonJS User zufriedenstellen. Die Spezifikation besitzt eine kompaktere Syntax als CommonJS und ähnlich zu AMD wird asynchrones Nachladen direkt unterstützt. Neben diesen Vorteilen wurde auch die Möglichkeit der statischen Code Analyse für Optimierungen geschaffen. 

ES6 bietet 2 Arten von Exporte: Named Exports (mehrere pro Modul) und Default Exports (einen pro Modul). \autocite{AxelRauschmayer}

\subsubsection{Named Exports}
\label{subsubsection:named_exports}

Mit Hilfe des Präfixes \lstinline{export} ist es möglich mehrere Elemente aus einem Modul zu exportieren. Dies gilt sowohl für Variablen, als auch Funktionen und Klassen. Sie werden anhand ihres Namens unterschieden und werden deshalb auch als Named Exports bezeichnet. \autocite{AxelRauschmayer}

\begin{lstlisting}[
    label=listing:named_exports,
	caption=Named Exports,
	language=JavaScript
]
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
\end{lstlisting}

Neben dem Beispiel in \ref{listing:named_exports}, gibt es noch weitere Wege um Named Exports zu erzeugen. Diese werden im Kapitel \ref{subsubsection:Syntax} als Überblick dargestellt.

\subsubsection{Default Exports}
\label{subsubsection:default_exports}

Es gibt den Fall das ein Modul auch nur ein Objekt exportiert. In der Frontendentwicklung tritt dies häufig auf wenn nur eine Klasse oder einen Konstruktor implementiert wird. Dabei wird er Default Export verwendet. Er ist wichtigste Element eines ECMAScript 6 Moduls und daher auch sehr leicht zu importieren. \autocite{AxelRauschmayer}

\begin{lstlisting}[
    label=listing:default_exports,
	caption=Default Exports,
	language=JavaScript
]
//------ myFunc.js ------
export default function () { ... };

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();

//------ MyClass.js ------
export default class { ... };

//------ main2.js ------
import MyClass from 'MyClass';
let inst = new MyClass();
\end{lstlisting}

Wie \ref{listing:default_exports} veranschaulicht, besitzt der Default Export keinen Namen. Beim Importieren wird daher meist der Modul Name für die Identifizierung verwendet.

In Wirklichkeit ist der Default Export auch ein Named Export mit dem speziellen Namen \lstinline{default}. Somit sind die folgenden Import Deklarationen in dem Beispiel \ref{listing:default_exports2} gleichbedeutend. \autocite{AxelRauschmayer}

 \begin{lstlisting}[
    label=listing:default_exports2,
    caption=Import Deklaration,
	language=JavaScript
]
import { default as foo } from 'lib';
import foo from 'lib';
\end{lstlisting}

Das gleiche gilt für den Export von Elementen.

\begin{lstlisting}[
    label=listing:default_exports3,
    caption=Export Deklaration,
	language=JavaScript
]
//------ module1.js ------
export default 123;

//------ module2.js ------
const D = 123;
export { D as default };
\end{lstlisting}

\subsubsection{Static Module Structure}
Bei anderen Module Systeme wie CommonJS muss man den Pragrammcode ausführen, um herrauszufinden welche Importe und Exporte verwendet werden. Die Spezifikation von ES 6 zwingen den Entwickler oder die Entwicklerin zu einer statischen Modul Struktur. In diesem Kapitel wird erläutert was dies bedeutet und welche Vorteile dadurch entstehen.
\autocite{AxelRauschmayer}

Eine statische Modul Struktur ermöglicht es durch kompilieren des Codes die darin befindlichen Importe und Exporte zu ermitteln. Es ist nicht nötig den Sourcecode auszuführen. In den folgenden Beispiel \ref{listing:commonjs_nonstatic} wird gezeigt warum dies bei CommonJS nicht möglich ist. \autocite{AxelRauschmayer}

\begin{lstlisting}[
    label=listing:commonjs_nonstatic,
    caption=Flexibele Struktur bei CommonJS,
	language=JavaScript
]
var mylib;
if (Math.random()) {
    mylib = require('foo');
} else {
    mylib = require('bar');
}

if (Math.random()) {
    exports.baz = ...;
}
\end{lstlisting}

Bei der CommonJS Deklaration aus Beispiel \ref{listing:commonjs_nonstatic} wird erst bei der Ausführung des Codes entschieden welcher Import beziehungsweise Export verwendet wird. Es6 Module besitzen nicht diese Flexibilität. Sie zwingen den Entwickler oder die Entwicklerin dazu eine flache und statische Modul Strukturen zu verwenden.Neben den Verlust der Flexibilität bringt dies jedoch einige Vorteile mit sich. \autocite{AxelRauschmayer}

\subsubsection{Vorteile}

\textbf{1. Schnellerer Lookup}

CommonJS liefert beim Anfordern von abhängigen Modulen ein Objekt zurück. Beim Aufruf von zum Beispiel \lstinline{lib.someFunc();} muss ein langsamer Property Lookup durchgeführt werden.

Im Gegensatz dazu sind die Inhalte bei dem Import einer ES6 Moduls bekannt. Der Zugriff auf die Properties kann daher optimiert werden. \autocite{AxelRauschmayer}

\bigskip

\textbf{2. Variablen Überprüfung}

Dank der statischen Modul Struktur, sind die verfügbaren Variablen innerhalb eines Moduls immer bekannt. Dazu zählen:
\begin{itemize}
\item Globale Variablen
\item Modul Importe
\item Modul Variablen
\end{itemize}
Dies bietet eine große Hilfe für Entwickler und Entwicklerinnen. Durch eine statische Überprüfung mit einem Linter werden frühzeitige Tippfehler oder auch nicht verfügbare Variablen erkannt.\autocite{AxelRauschmayer}

\bigskip

\textbf{3. Macro Support}

(scheint nicht wirklich viel verwendet zu werden weiterer research nötig)

\begin{lstlisting}[
    label=listing:sweetjs_macro,
    caption=Macros in Javascript,
	language=JavaScript
]
syntax hi = function (ctx) {
  return #`console.log('hello, world!')`;
};
hi
\end{lstlisting}



\bigskip

\textbf{4. Type Support}

(scheint nicht wirklich viel verwendet zu werden weiterer research nötig)

\bigskip

\textbf{5. Unterstützung mehrerer Sprachen}

(scheint nicht wirklich viel verwendet zu werden weiterer research nötig)

\subsubsection{Syntax}
\label{subsubsection:Syntax}

\begin{lstlisting}[
    label=listing:imports,
	caption=Import Möglichkeiten in ES6,
	language=JavaScript
]
import name from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member as alias } from "module-name";
import { member1 , member2 } from "module-name";
import { member1 , member2 as alias2 , [...] } from "module-name";
import defaultMember, { member [ , [...] ] } from "module-name";
import defaultMember, * as alias from "module-name";
import defaultMember from "module-name";
import "module-name";
\end{lstlisting}

\autocite{ES6Imports}

\begin{lstlisting}[
    label=listing:exports,
	caption=Export Möglichkeiten in ES6,
	language=JavaScript
]
export { name1, name2, ..., nameN };
export { variable1 as name1, variable2 as name2, ..., nameN };
export let name1, name2, ..., nameN; // oder: var
export let name1 = ..., name2 = ..., ..., nameN; // oder: var, const

export default expression;
export default function (...) { ... } // oder: class, function*
export default function name1(...) { ... } // oder: class, function*
export { name1 as default, ... };

export * from ...;
export { name1, name2, ..., nameN } from ...;
export { import1 as name1, import2 as name2, ..., nameN } from ...;
\end{lstlisting}