\section{Einleitung}

Für Javascript Webentwickler ist das NPM Registry eines der wichtigsten Werkzeuge. Es bietet eine Plattform für Entwickler, um Sourcecode mit anderen zu teilen, bestehende Module herunterzuladen und in die eigenen Anwendung zu integrieren. Seit dem Release wurden über 600.000 verschiedene Software Pakete hinzugefügt und mit mehr als einer Millarden Downloads pro Woche ist es zu einer zentralen Bibliothek von Frameworks, Libaries und Werkzeuge für die Javascript Entwicklung geworden. \autocite{Npmdocs}

Die Anzahl der Module und deren komplexe Abhängigkeiten zueinander führten jedoch im Bereich der Frontendentwicklung zu fundamentalen Problemen. Neben der Dependency Hell, dem wohl bekannteste dieser Probleme, ist ebenso entscheidend die an den Browser zu übertragende Datenmenge möglichst gering zu halten. Um dies zu erreichen sollten die Entwickler und die Entwicklerinnen unnötige Versions Duplikate und unerreichbare Zweige im Programmcode vermeiden.\autocite{DominikWilkowski}

Die benötigte Datenmenge einer Webseite hat einen negativen Effekt auf Antwortzeit einer Webseite und es existiert bereits reichlich Literatur zu den Auswirkungen der Download Zeit zu der Nutzerzufriedenheit. Bereits 1997 erkannte \textcite{Nielson1997}, die Bedeutung der Lade Geschwindigkeit einer Webseite auf die User Experience. in den 90ern waren große Bilder einer der Hauptgründe für eine Schlechte Website Performance. Mehr als 10 Jahre später, ist die Bildergröße immer noch wichtig, jedoch Aufgrund der allgemein schnellern Internetverbindungen sind die Auswirkung auf die Ladezeit nicht mehr so schwerwiegend. Auch wenn die Gründe für eine langsame Webseite sich verändert haben, bleiben die Antwortzeit Limits die selben. \autocite{Nielson2010}

\begin{itemize}
\item 0.1 Sekunden gibt das Gefühl einer sofortigen Antwort. Das Ergebnis fühlt sich an, als wäre es vom Benutzer verursacht worden, nicht vom Computer. Dieses Level der Reaktionsfähigkeit wird von den Benutzern oder Benutzerinnen als direkte Manipulation empfunden.
\item 1 Sekunde hält den Gedankenfluss des Benutzers nahtlos. Benutzer können eine Verzögerung wahrnehmen und somit wissen, dass der Computer das Ergebnis erzeugt, aber sie fühlen sich immer noch in der Kontrolle über das Gesamterlebnis und haben nicht das Gefühl auf den Computer zu warten. Dieser Grad an Reaktionsfähigkeit ist für eine gute Navigation erforderlich.
\item 10 Sekunden hält die Aufmerksamkeit des Benutzers oder der Benutzerin. In dem Bereich von 1-10 Sekunden fühlen sich die Benutzer und Benutzerinnen auf jeden Fall dem Computer ausgeliefert und wünschen sich, dass es schneller geht. Nach 10 Sekunden fangen sie an, über andere Dinge nachzudenken, was es schwieriger macht, ihre Gehirne wieder in die Spur zu bringen, wenn der Computer endlich reagiert.
\end{itemize}

Jedes eingesparte Bit verringert die Zeit bis der Nutzer oder die Nutzerin eine Antwort erhält und hat somit eine positive Auswirkung auf die Benutzerzufriedenheit. Im Bereich der JavaScript Webentwicklung wird Verrrigerung die Datenmenge vorallem durch die Minification des Programmcode erreicht. Der Static Bundler Webpack bietet, seit der Veröffentlichung von Version 2 die Möglichkeit, mit Hilfe von Tree Shaking, nicht benutzten Code zu bereinigen und somit die Datenmenge noch mehr zu verkleinern. \autocite{WebpackTreeShaking}


\section{Static Module Bundler}
Static Module Bundler wie Webpack und RollupJS ermittelt alle für die Anwendung benötigten Module und bündelt diese anschließend in einer oder mehrere Dateien. Dafür wird ausgehend von konfigurierten Einstiegspunkten ein Baum aus Abhängigkeiten erzeugt. Neben dem eigenen Programmcode beinhaltet dieser auch Npm Packete und sogar statische Assets wie Bilder oder CSS Dateien. Die Abhängigkeiten werden aufgelöst um daraus wieder je nach Konfiguration eine oder mehrere Bundle Dateien zu erzeugen. Je nach Anwendungsfall kann es von Vorteil sein den Programmcode als eine größere Datei oder in mehreren Teilen an den Browser auszuliefern, um ein möglichst schnelles Laden der Webseite zu gewährleisten.
\autocite{RollupJSDocs,WebpackConcepts}

Bundler so wie Webpack umhüllen jedes Code Module in Funktionen. Damit wird eine Browser freundliche Implementierung und das Laden der Assets je nach Bedarf gewährleistet \autocite{RichHarris}. Zu beachten ist der Unterschied zwischen Laden und Bündlen von Modulen. Werkzeuge wie SystemJS, wird verwendet, um Module zur Laufzeit im Browser zu laden und zu übertragen. Im Gegensatz dazu werden bei Webpack Module durch sogennante Loader transpiliert und gebündelt bevor die den Browser erreichen. \autocite{WebpackComparison}

Dabei hat jede Methode ihre Vorteile und Nachteile. Das Laden und Übertragen von Modulen zur Laufzeit kann viel Aufwand für größere Sites und Anwendungen mit vielen Modulen verursachen. Aus diesem Grund ist SystemJS sinnvoller für kleinere Projekte, bei denen weniger Module benötigt werden. \autocite{WebpackComparison}

\section{Modules in JavaScript}
\label{section:modules_in_javaScript}
In traditionellen JavaScript Webprojekten werden alle Abhängigkeiten als Liste aus \lstinline{<script>} tags definiert. Es ist die Aufgabe des Entwicklers oder der Entwicklerin sicherzustellen das diese in der richtigen Reihenfolge zur Verfügung gestellt werden. Je komplexer die Abhängigkeiten zwischen dem  Programmcode, Frameworks und Libaries werden, desto schwieriger wird die Wartung und die richtige Platzierung neuer Einträge in der richtigen Reihenfolge. Es wurden bereits mit verschiedenen Modul Spezifikationen versucht diese Schwierigkeiten für Entwickler und Entwicklerinnen zu vereinfachen. \autocite{SebastianPeyrott}

\subsection{CommonJS}
Das Ziel von CommonJS ist eine Modul Spezifikation zur Erleichterung der Entwicklung von Serverseitigen JavaScript Anwendungen.NodeJS Entwickler verfolgte anfangs diesen Ansatz, entschieden sich im späteren Verlauf jedoch dagegen. Dennoch wurde die Implementierung stark von der CommonJS Spezifikation beeinflusst. \autocite{SebastianPeyrott}

\begin{lstlisting}[
    label=listing:commonjs,
	caption=CommonJS Module,
	language=JavaScript
]
// In circle.js
const PI = Math.PI;

exports.area = (r) => PI * r * r;

exports.circumference = (r) => 2 * PI * r;

// In some file
const circle = require('./circle.js');
console.log( `The area of a circle of radius 4 is ${circle.area(4)}`);
\end{lstlisting}

Sowohl bei CommonJS als auch bei der NodeJS Implementierung gibt es zwei Elemente um mit dem Modul System zu interagieren: \lstinline{require} und \lstinline{exports}. \lstinline{require} wird benötigt um ein anderes Modul in den aktuellen Scope zu importieren. Dabei wird als Parameter die Modul-id angegeben. Diese ist entweder der Name des Moduls innerhalb des \lstinline{node_modules} Ordner oder der gesamte Pfad. \lstinline{exports} dient zur Definition einer Modul Schnittstelle. Jede Property des \lstinline{exports} Objekts wird als öffentliches Element exportiert. Der Unterschied zwischen NodeJS und CommonJS liegt vorallem im \lstinline{module.exports} Objekt. Dies erfüllt die selbe Aufgabe wie bei CommonJS das \lstinline{exports} Objekt. Abschließend bleibt zu erwähnen das die Module synchron geladen werden. Sprich in dem Moment und in der Reihnfolge in der sie mit \lstinline{require} angegeben wurden.\autocite{SebastianPeyrott}

\subsection{Asynchronous Model Definition (AMD)}

Das Entwickler Team von AMD spaltete sich wärend der Entwicklung von CommonJS ab. Der Haupt Unterschied zwischen diese beiden Systemen liegt in dem asynchronen laden von Ressourcen. \autocite{SebastianPeyrott}

\begin{lstlisting}[
    label=listing:amd,
	caption=Asynchronous Model Definition,
	language=JavaScript
]
//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
});

// Or:
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');

    return function () {};
});
\end{lstlisting}

Das asynchrone Laden wird ermöglicht durch einen Funktionsaufruf nach dem anfordern der  Abhängigkeiten. Libaries die nicht voneinander abhängig sind können somit zur selben Zeit geladen werden. Dies ist besonders wichtig für die Frontend Entwicklung, da dort die Startzeit einer Anwendung essenziell für ein gutes Benutzererlebnis ist. \autocite{SebastianPeyrott}

\subsection{ECMAScript 6}
Ziel der ECMAScript 6 Modules war es ein Format zu kreieren, welches sowohl AMD, als auch CommonJS User zufriedenstellen. Die Spezifikation besitzt eine kompaktere Syntax als CommonJS und ähnlich zu AMD wird asynchrones Nachladen direkt unterstützt. Neben diesen Vorteilen wurde auch die Möglichkeit der statischen Code Analyse für Optimierungen geschaffen. 

ES6 bietet 2 Arten von Exporte: Named Exports (mehrere pro Modul) und Default Exports (einen pro Modul). \autocite{Rauschmayer2014}

\subsubsection{Named Exports}
\label{subsubsection:named_exports}

Mit Hilfe des Präfixes \lstinline{export} ist es möglich mehrere Elemente aus einem Modul zu exportieren. Dies gilt sowohl für Variablen, als auch Funktionen und Klassen. Sie werden anhand ihres Namens unterschieden und werden deshalb auch als Named Exports bezeichnet. \autocite{Rauschmayer2014}

\begin{lstlisting}[
    label=listing:named_exports,
	caption=Named Exports,
	language=JavaScript
]
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
\end{lstlisting}

Neben dem Beispiel in \ref{listing:named_exports}, gibt es noch weitere Wege um Named Exports zu erzeugen. Diese werden im Kapitel \ref{subsubsection:Syntax} als Überblick dargestellt.

\subsubsection{Default Exports}
\label{subsubsection:default_exports}

Es gibt den Fall das ein Modul auch nur ein Objekt exportiert. In der Frontendentwicklung tritt dies häufig auf wenn nur eine Klasse oder einen Konstruktor implementiert wird. Dabei wird er Default Export verwendet. Er ist wichtigste Element eines ECMAScript 6 Moduls und daher auch sehr leicht zu importieren. \autocite{Rauschmayer2014}

\begin{lstlisting}[
    label=listing:default_exports,
	caption=Default Exports,
	language=JavaScript
]
//------ myFunc.js ------
export default function () { ... };

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();

//------ MyClass.js ------
export default class { ... };

//------ main2.js ------
import MyClass from 'MyClass';
let inst = new MyClass();
\end{lstlisting}

Wie \ref{listing:default_exports} veranschaulicht, besitzt der Default Export keinen Namen. Beim Importieren wird daher meist der Modul Name für die Identifizierung verwendet.

In Wirklichkeit ist der Default Export auch ein Named Export mit dem speziellen Namen \lstinline{default}. Somit sind die folgenden Import Deklarationen in dem Beispiel \ref{listing:default_exports2} gleichbedeutend. \autocite{Rauschmayer2014}

 \begin{lstlisting}[
    label=listing:default_exports2,
    caption=Import Deklaration,
	language=JavaScript
]
import { default as foo } from 'lib';
import foo from 'lib';
\end{lstlisting}

Das gleiche gilt für den Export von Elementen.

\begin{lstlisting}[
    label=listing:default_exports3,
    caption=Export Deklaration,
	language=JavaScript
]
//------ module1.js ------
export default 123;

//------ module2.js ------
const D = 123;
export { D as default };
\end{lstlisting}

\subsubsection{Static Module Structure}
Bei anderen Module Systeme wie CommonJS muss man den Pragrammcode ausführen, um herrauszufinden welche Importe und Exporte verwendet werden. Die Spezifikation von ES 6 zwingen den Entwickler oder die Entwicklerin zu einer statischen Modul Struktur. In diesem Kapitel wird erläutert was dies bedeutet und welche Vorteile dadurch entstehen.
\autocite{Rauschmayer2014}

Eine statische Modul Struktur ermöglicht es durch kompilieren des Codes die darin befindlichen Importe und Exporte zu ermitteln. Es ist nicht nötig den Sourcecode auszuführen. In den folgenden Beispiel \ref{listing:commonjs_nonstatic} wird gezeigt warum dies bei CommonJS nicht möglich ist. \autocite{Rauschmayer2014}

\begin{lstlisting}[
    label=listing:commonjs_nonstatic,
    caption=Flexibele Struktur bei CommonJS,
	language=JavaScript
]
var mylib;
if (Math.random()) {
    mylib = require('foo');
} else {
    mylib = require('bar');
}

if (Math.random()) {
    exports.baz = ...;
}
\end{lstlisting}

Bei der CommonJS Deklaration aus Beispiel \ref{listing:commonjs_nonstatic} wird erst bei der Ausführung des Codes entschieden welcher Import beziehungsweise Export verwendet wird. Es6 Module besitzen nicht diese Flexibilität. Sie zwingen den Entwickler oder die Entwicklerin dazu eine flache und statische Modul Strukturen zu verwenden.Neben den Verlust der Flexibilität bringt dies jedoch einige Vorteile mit sich. \autocite{Rauschmayer2014}

\subsubsection{Vorteile}

\textbf{1. Schnellerer Lookup}

CommonJS liefert beim Anfordern von abhängigen Modulen ein Objekt zurück. Beim Aufruf von zum Beispiel \lstinline{lib.someFunc();} muss ein langsamer Property Lookup durchgeführt werden.

Im Gegensatz dazu sind die Inhalte bei dem Import einer ES6 Moduls bekannt. Der Zugriff auf die Properties kann daher optimiert werden. \autocite{Rauschmayer2014}

\bigskip

\textbf{2. Variablen Überprüfung}

Dank der statischen Modul Struktur, sind die verfügbaren Variablen innerhalb eines Moduls immer bekannt. Dazu zählen:
\begin{itemize}
\item Globale Variablen
\item Modul Importe
\item Modul Variablen
\end{itemize}
Dies bietet eine große Hilfe für Entwickler und Entwicklerinnen. Durch eine statische Überprüfung mit einem Linter werden frühzeitige Tippfehler oder auch nicht verfügbare Variablen erkannt.\autocite{Rauschmayer2014}

\bigskip

\textbf{3. Macro Support}

Wenn eine JavaScript Engine Macros unterstützen, können Entwickler und Entwicklerinnen neue Sytaxen der Sprache hinzufügen.

\bigskip

\textbf{4. Type Support}

Eine statische Typprüfung ist nur möglich, wenn die Typdefinitionen statisch gefunden werden. In weitere Folge können Typen aus Modulen importier werden, wenn diese eine statische Struktur besitzen.

\bigskip

\textbf{5. Unterstützung anderer Sprachen}

Um das Kompilieren von Sprachen mit Macros und statischen Typen zu JavaScript zu ermöglichen, sollten die Module, aus den 2 zuvor gennanten Gründen, eine statische Struktur aufweisen.

\subsubsection{Imports}
\label{subsubsection:importes}

CommonJS sind Importe Kopien der exportierten Werte. Module Importe in ECMAScript 6 hingegen sind schreibgeschützte Views auf die exportierten Entitäten. Dies bedeutet das Variablen die innerhalb eines Modules deklariert wurden wärend der gesamten Programmlaufzeit bestehen bleiben. \autocite{Rauschmayer2018}


\begin{lstlisting}[
    label=listing:views,
    caption=Importe sind Views auf exportierte Entitäten,
	language=JavaScript
]
//------ lib.js ------
export let counter = 3;
export function incCounter() {
    counter++;
}

//------ main1.js ------
import { counter, incCounter } from './lib';

// The imported value `counter` is live
console.log(counter); // 3
incCounter();
console.log(counter); // 4

// The imported value can't be changed.
counter++; // TypeError
\end{lstlisting}

In anderen Worten jeder Import ist eine Live-Verbindung zu den exportierten Daten. \textcite{Rauschmayer2018} zeigt die Unterschiede zwischen verschiedenen Importen in ES6:
\begin{itemize}
\item Unqualified imports wie zum Beispiel \lstinline{import x from 'foo'} verhalten sich wie mit \lstinline{const} deklarierte Variablen.
\item Wird ein gesamtes Module Objekt importiert \lstinline{import * as foo from 'foo'}, so verält es sich wie  ein mit \lstinline{Object.freeze} geschütztes Objekt.
\end{itemize}

Gemäß \textcite{ECMAScript} erzeugt die Methode \lstinline{CreateImportBinding(N, M, N2)} eine unveränderbare indirekte Bindung zu dem Exporten eines anderen Moduls. Dabei wird überprüft ob bereits ein Binding mit dem Namen \textbf{N} existiert. \textbf{M} ist die Bezeichnung des Moduls und \textbf{N2} ist der Name des von \textbf{M} exportierten Objekts.
Im Weiteren is ebenfalls zu beachten, dass es nicht möglich ist die Werte von Importen zu ändern, man kann jedoch die Objekte ändern auf welche verwiesen wird. \autocite{Rauschmayer2018}

\begin{lstlisting}[
    label=listing:readonly_imports,
    caption=Importe sind Views auf exportierte Entitäten,
	language=JavaScript
]
//------ lib.js ------
export let obj = {};

//------ main.js ------
import { obj } from './lib';

obj.prop = 123; // OK
obj = {}; // TypeError
\end{lstlisting}

Exporte in ES6 werden über den Export Eintrag verwaltet. Bis auf reexportierte Module besitzten alle Einträgen die folgenden 2 Namen: 

\begin{itemize}
\item Local Name: Ist der Name unter dem der Export im Module gespeichert ist.
\item Export Name: Importierende Module verwenden diesen Namen, um Zugang zu dem Export zu erhalten. Nachdem importieren einer Entität, wird diese stehts mittels des Pointers erreicht. Der Pointer besteht dabei aus 2 Teilen Modul und Local Name und referenziert auf ein Binding innerhalb des Moduls.
\end{itemize}
\autocite{Rauschmayer2018}

Die nachfolgende angepasste Tabelle aus \textcite{ECMAScript} gibt einen Überblick über die Local und Export Namen verschiedener Export Varianten:

\begin{table}[H]
\centering
\caption{Local und Export Namen verschiedene Export Varianten}
\label{local_export_names}
\begin{tabular}{|l|l|l|}
\hline
Export Statement Form            & Export Name & Local Name \\ \hline
export var v;                    & v           & v          \\ \hline
export default function f()\{\}; & default     & f          \\ \hline
export default function()\{\};   & default     & *default*  \\ \hline
export default 42;               & default     & *default*  \\ \hline
export \{x\};                    & x           & x          \\ \hline
export \{v as x\};               & x           & v          \\ \hline
export \{x\} from "mod";         & x           & null       \\ \hline
export \{v as x\} from "mod";    & x           & null       \\ \hline
export * from "mod";             & null        & null       \\ \hline
\end{tabular}
\end{table}

\subsubsection{Syntax}
\label{subsubsection:Syntax}

\begin{lstlisting}[
    label=listing:imports,
	caption=Import Möglichkeiten in ES6,
	language=JavaScript
]
import name from "module-name";
import * as name from "module-name";
import { member } from "module-name";
import { member as alias } from "module-name";
import { member1 , member2 } from "module-name";
import { member1 , member2 as alias2 , [...] } from "module-name";
import defaultMember, { member [ , [...] ] } from "module-name";
import defaultMember, * as alias from "module-name";
import defaultMember from "module-name";
import "module-name";
\end{lstlisting}

\begin{lstlisting}[
    label=listing:exports,
	caption=Export Möglichkeiten in ES6,
	language=JavaScript
]
export { name1, name2, ..., nameN };
export { variable1 as name1, variable2 as name2, ..., nameN };
export let name1, name2, ..., nameN; // oder: var
export let name1 = ..., name2 = ..., ..., nameN; // oder: var, const

export default expression;
export default function (...) { ... } // oder: class, function*
export default function name1(...) { ... } // oder: class, function*
export { name1 as default, ... };

export * from ...;
export { name1, name2, ..., nameN } from ...;
export { import1 as name1, import2 as name2, ..., nameN } from ...;
\end{lstlisting}


\section{Tree Shaking}

Tree Shaking bedeutet im Javascript Umfeld Dead-Code Elimination. Der Begriff und das dahinterliegende Konzept wurde durch den ES2015 Modul Bundler Rollup populär. Das Konzept des Tree Shaking beruht auf der statischen Struktur von ES6 Modulen. Diese werden im Zusammenhang mit Bundlern wie Webpack oder RollupJS oft auch als Pure Modules oder Modules oder Harmony Modules bezeichnet. \autocite{WebpackTreeShaking}

Wie bereits im Kapitel \ref{section:modules_in_javaScript} gezeigt wurde, ermöglicht die ES6 Spezifikation, sowohl die statische Analyse von Modulen, als auch die Verwendung einer Teilmenge der zur Verfügung gestellten Exporte.
Für das nachfolgende Beispiel wurde Webpack verwendet.

\begin{lstlisting}[
    label=listing:treeshacking_helpers,
	caption=helpers.js,
	language=JavaScript
]
export function hello() {
  return 'hello';
}
export function world() {
  return 'world';
}

export default {
  hello,
  world
}
\end{lstlisting}

\begin{lstlisting}[
    label=listing:treeshacking_index,
	caption=index.js,
	language=JavaScript
]
import {hello} from './helpers';

let elem = document.getElementById('output');
elem.innerHTML = `Output: ${hello()}`;
\end{lstlisting}

Listing \ref{listing:treeshacking_index} zeigt die Verwendung des zuvor Implementierten \lstinline{helpers.js} Moduls. Dabei ist zu beachten das die lediglich die Methode \lstinline{hello} importiert und verwendet wird. \lstinline{world} gilt somit als Dead Code oder Unused Export und wird in der gebündelten Anwendung nicht benötigt.

Damit Webpack

\begin{lstlisting}[
    label=listing:treeshacking_bundle,
	caption=bundle.js,
	language=JavaScript,
    firstnumber=79
]
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = hello;
/* unused harmony export world */
function hello() {
  return 'hello';
}
function world() {
  return 'world';
}

/* unused harmony default export */ var _unused_webpack_default_export = ({
  hello: hello,
  world: world
});
\end{lstlisting}

Um die unnötigne Codezeilen zu entfernen werden diese zuerst von Webpack makiert. In Listing \ref{listing:treeshacking_bundle} wurde, sowohl der Default Export, als auch die \lstinline{world} Funktion mit \lstinline{unused harmony} makiert.

Webpack entfernt den unerwünschten Code nicht, erst der darauf folgenden Minifier erkennt die \lstinline{unused harmony} Annotationen und entfernt diese Segmente.

Die daraus resultierende Bundle Datei beinhaltet eine stark verkleinerte \lstinline{hello} Funktion und die nicht benötigte Methode \lstinline{world} wurde aus der Datei entfernt. Auch wenn in diesem Beispiel der Gewinn nicht groß ist, kann Tree Shaking dazu beitragen die Bundle Datei in größeren Projekte signifikant zu verkleinern.
\autocite{WebpackTreeShaking}

\subsection{Webpack}

Um Tree Shaking mit Webpack zu ermöglichen sind einige Konfigurationen nötig. 
Zuvor ist es wichtig einen genaueren Blick darauf zu werfen wie Webpack mit ES6 Modulen arbeitet.

Eine große Schwierigkeit bei der Verwendung von ES6 ist die Browser Inkompatibilität. Erstens dauert es eine gewisse Zeit bis die neuen Spezifikationen in den Browsern von den Herstellern implementiert werden können \autocite{CanIUseES6}. Zweitens benutzt ein beachtlicher Teil der Clients nicht die aktuellste verfügbare Version \autocite{CanIUseUsageTable}.

Um das Problem mit der Inkompatibilität zu umgehen werden JavaScript Compiler wie Babel verwendet. Diese verwandeln Es6 in einen für die meisten Browser Kompatiblen JavaScript Code. Somit können Entwickler und Entwicklerinnen bereits die neusten Funktionen verwenden ,ohne das diese von dem Großteil der Browser unterstützt werden muss.\autocite{Babel}

Per Default wird von Babel jedes JavaScript Modul in CommonJS konvertiert. Durch die dynamische Implementierung von CommonJS Modulen können diese jedoch nicht statisch Analysiert werden. Es ist daher entscheidend um ein erfolgreiches Tree Shaking zu ermöglichen, dies zu ändern.\autocite{Babel}

\begin{lstlisting}[
    label=listing:treeshacking_config,
	caption=webpack.config.js,
	language=JavaScript,
]
{
  entry: './index.js',
  output: {
    filename: 'dist/es6-modules/bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        query: {
          presets: [
            ['es2015', { modules: false }]
          ]
        }
      }
    ]
  }
}
});
\end{lstlisting}

Listing \ref{listing:treeshacking_config} zeigt eine typische Tree Shaking Konfiguration von Babel und Webpack. Besonders wichtig ist die \lstinline{modules: false} Option von Babel. Mit dieser kann man die automatische Modul Transformationen verändern. Neben dem \lstinline{false} Wert der diese komplett deaktiviert, ist es ebenfalls möglich andere Optionen anzugeben (\lstinline{"amd" | "umd" | "systemjs" | "commonjs"}). \autocite{Babel}

\subsection{RollupJS}
Neben Webpack wurde das Tree shaking Konzept vor allem durch den ES6 Module Bundler RollupJS bekannt \autocite{WebpackTreeShaking}. Dieser wird vor allem empfohlen beim Entwickeln von Libaries. Webpack wiederum bietet eine bessere Unterstützung für Assets wie Bilder oder CSS und gilt daher als besseres geeignet für die Erstellung von Apps. \autocite{RichHarris}

Der Unterschied zwischen den Bundlern liegt in der Art und weise wie die einzelnen Module im Bundle File verpackt sind. Webpack hüllt jedes Modul in eine Funktion mit einer browser-freundlichen Implementierung von \lstinline{require} \autocite{RichHarris}. Features wie On-demand Loading werden dadurch erst möglich. \textcite{NolanLawson} konnte jedoch zeigen das dies im weiteren auch dazu führt, dass je mehr Module verwendet werden auch der damit einhergehende Overhead wächst.

RollupJS verwendet im Gegensatz die Möglichkeiten von ES6. Der gesamte Code landet an einem Platz und wird in einem Durchgang verarbeitet. Damit wird der Code schlanker und kann schneller starten. \autocite{RichHarris}

\subsection{Side Effects}
\label{subsection:side_effects}
In dieser Arbeit wird Tree Shaking aus der Perspektive zweier Entwicklergruppen betrachtet. 

Zum einen jene Entwickler und Entwicklerinnen welche viel projektinternen JavaScript Code in ihren Webpack Projekten verwenden. Ihr Ziel ist es eine oder mehrere möglichst kleiner Bundle Dateien an den Client auszuliefern, für schnelle Seitenaufrufe und eine angenehmes Benutzererlebnis.

Die zweite Gruppe ist jene der Javascript Libary und Framework Entwickler. Ihr Sourcecode wird von vielen Projekten in verschiedener Art und Weise verwendet. In vielen Fällen wird in den Javascript Projekten nur ein kleiner klein der importierten Libaries verwendet. Wenn diese Tree Shaking unterstützt, können jedoch Bundler wie Webpack, den unnötig Code beim kompilieren der Bundle Datei entfernen.

In diesem Kapitel werden meherere Hindernisse für die beiden Benutzergruppen im Bezug auf Side Effects im Code veranschaulicht und in weitere Folge Maßnahmen zu Vermeidung dieser ermittelt. 

Umfangreiche und weitverbreitete JavaScript Libaries wie zum Beispiel Lodash\footnote{https://lodash.com/ - besucht am 26.05.2018} und jQuery\footnote{https://jquery.com/ - besucht am 26.05.2018} bieten eine große Anzahl an nützlichen Tools. Sie werden meistens als NPM Modul installiert und anschließend in den Projektdateien als Import eingebunden. Zu meist werden nur Teile von den zu Verfügung gestellten Funktionalitäten auch wirklich verwendet. Das kann dazuführen das ein erheblich Teil der von Webpack erzeugten Bundledatei aus nicht benötigten Code besteht. Plugins wie der Webpack Visualizer bieten eine einfache Möglichkeit, um festzustellen, welche Module in der von Webpack generierten Bundle Datei am meisten Speicherplatz einnehmen.

Jedoch bietet unter anderem Webpack eine Möglichkeit für Libary Entwickler und Entwicklerinnen diese so zu Implementieren ,dass der nicht benötigte Libary Sourcecode beim builden entfernt wird.
Durch die Verwendung von \lstinline{sideEffects: false} in der package.json Datei innerhalb der Libary, wird Webpack mitgeteilt das Tree Shaking nicht nur auf den üblichen Projektcode anzuwenden, sondern ebenfalls auf den Code der sich im Libary Ordner \lstinline{node_modules} befindet.

Dabei werden Importdeklarationen wie \lstinline|import {a, b} from "big-module-with-flag"| von Webpack erkannt und beim Bau der Applikation zu \lstinline|import a from "big-module-with-flag/a" import b from "big-module-with-flag/b"| umgeschrieben. Somit werden in der Bundle Datei auch nur die zwei von dem Entwickler oder der Entwicklerin verwendeten Methoden importiert und der restliche Libary Code entfernt \autocite{WebpackTreeShaking}. Zur Veranschaulichung dient ein ausführlich dokumentiertes Beispiel\footnote{https://github.com/webpack/webpack/tree/master/examples/side-effects - besucht am 26.05.2018}. 

Wenn mit Hilfe von \lstinline{sideEffects: false} ein Modul als rein bezeichnet wird, werden alle nicht verwendeten Methoden, Klassen oder Objekte aus dem Code entfernt. Dies kann jedoch die Funktionsweise erheblich stören und SideEffects können entstehen. Diese sind Code Segmente, welche beim Tree Shaking nicht entfernt werden dürfen. Dies wird im Weiteren mittels eines Beispiels näher erläutert.

\begin{lstlisting}[
    label=listing:lib.js,
	caption=Libary mit Side Effects,
	language=JavaScript,
]
	import a from 'a'
    import b from 'b'
    
    console.log("das ist ein sideeffect")
    
    export {
    		a,
    		b
    }
\end{lstlisting}

\begin{lstlisting}[
    label=listing:app.js,
	caption=Verwendung der Libary,
	language=JavaScript,
]
	import { a } from 'lib'
    
    console.log("a:", a)
\end{lstlisting}

Listing \ref{listing:lib.js} zeigt eine Beispiel für einen Libary Entry Point. Dieser exportiert alle Funktionalitäten die zur Verfügung gestellt werden.

Beim Tree Shaking werden alle Imports umgeschrieben. Dabei wird \lstinline|import { a } from 'lib'| in Listing \ref{listing:app.js} zu \lstinline{import a from 'lib/a'} und somit wird jeglicher Programm Code in lib.js nicht ausgeführt. DIe \lstinline{console.log} Nachricht in Zeile 4 wirs somit nie angezeigt. Dies führt vorallem dann zu Problemen, wenn sich Side Effects auf Exporte in der Datei auswirken. 

\begin{lstlisting}[
    label=listing:lib.js_with_sideeffect,
	caption=Side Effect mit Auswirkung auf Exporte,
	language=JavaScript,
]
	import { a } from 'lib'
    
	a.value = 'this value is dangerous'    
    
     export {
    		a
    }
\end{lstlisting}

In Listing \ref{listing:lib.js_with_sideeffect} wird wie in Listing \ref{listing:lib.js} \lstinline{a} exportiert. Davor wird in der Zeile 3 die \lstinline{importantValue} Eigenschaft hinzugefügt. Bei aktivem Tree Shaking wird \lstinline{a} jedoch direkt mit \lstinline{import a from 'lib/a'} importiert. \lstinline{a.value} wird somit nie angelegt und kann nicht verwendet werden. Diese Unterschiede sind in spätere Folge für Benutzer und Benutzerinnen nur schwer nachzuvoll ziehen und Entwickler und Entwicklerinnen sollten bei der Erstellung einer Libary unbedingt diese vermeiden.\autocite{WebpackTreeShaking}

Mit \lstinline{sideEffects: false} betrachtet Webpack den gesamten Projektcode als rein von Side Effects. Sind für die Ordnungsgemäße Ausführung jedoch einige Importe nötig, können Entwickler und Entwicklerinnen diese als String Array angegeben. Dieses akzeptiert relative Pfade , absolute Pfade und glob Pattern zu den relevaten Dateien. Webpack verwendet Micromatch \footnote{https://github.com/micromatch/micromatch - besucht am 21.06.2018} zur Auflösung der Pfade.\autocite{WebpackTreeShaking}

CSS Dateien sind ein gutes Beispiel für Importe die in jedem Fall in dem gebündelten Programmcode enthalten sein müssen. Bei der Verwendung des CSS-Loader und dem Importieren in einer Projektdatei, wird der CSS Code analysiert und die darin befindlichen Klassen stehen zur Verfügung. Sollten diese aber durch Tree Shaking entfernt werden, fehlen die CSS Klassen und die dazugehörigen Styles in der Anwendung.
\autocite{WebpackTreeShaking}

\begin{lstlisting}[
    label=listing:sideeffectful.js,
	caption=sideeffectful.js mit CSS Side Effect,
	language=JavaScript,
]
	import './styles.css'

	console.log('sideeffectful file')

	export const sideeffect = 'sideeffect'
\end{lstlisting}

\begin{lstlisting}[
    label=listing:styles.css,
	caption=styles.css,
	language=HTML,
]
	.myClass {
    		background-color: blue;
	}
\end{lstlisting}

Listing \ref{listing:sideeffectful.js} zeigt ein JavaScript Modul, welches die CSS Datei \lstinline{styles.css} importiert. Mit der \lstinline{sideEffects: false} Webpack Konfiguration wird \lstinline{import './styles.css'} in Zeile 1 als "unused export" erkannt und ist in den gebündelten Anwendung nicht mehr vorhanden. \lstinline{console.log('sideeffectful file')} und \lstinline{export const sideeffect = 'sideeffect'} werden jedoch noch ausgeführt.
Im Gegensatz dazu wird \lstinline{sideEffects: ["*.css"]} in der Konfigurationsdatei verwendet. Wird der CSS Import mit in die Bundle Datei übernommen. Auch wenn dies wegen dem Minify Schritt nicht sofort erkenntlich ist. Ist folgendes Code Segment darin zu finden \lstinline|function(e,n,o){(e.exports=o(2)(!1)).push([e.i,".myClass {\n    background-color: blue;\n}",""])}|.\autocite{WebpackTreeShaking}

\subsubsection{Untersuchung von JavaScript Libaries}
\label{subsubsection:untersuchung_von_js_libs}
Es existieren bereits Projekte auf NPM die Tree Shaking verwenden. Durch eine Sourcecode Analyse sollen zusätzliche Erkenntnisse gewonnen werden, über die zum Einsatz kommenden Design Patterns und Möglichkeiten die Entwickler und Entwicklerinnen mit Linting bei der Implementierung dieser zu unterstützen.
In weitere Folge werden am Ende dieser Arbeit, die ausgewählten Projekte mit dem ES Lint Tree Shaking Plugin auf Fehler und Warnungen getestet. Dabei sollten keine Fehler angezeigt werden, um die richtige Funktionweise des Plugins sicherzustellen.

\textbf{Auswahlkriterien}

Die wichtigsten Kriterien für die zur Analyse ausgewählten Projekte ist zum einen die Verwendung eines Static Bundler und zum anderen eine bereits bestehende Implementierung von Tree Shaking. Um dies festzustellen wird zuerst geprüft ob eine package.json Datei im Repository existiert.

Anschließend wird in dieser nach \lstinline{sideeffects} gesucht. Wie bereits im Kapitel \ref{subsubsection:side_effects} veranschaulicht diehnt die \lstinline{sideeffect} Einstellung dazu dem Bundler anzuzeigen, dass nur die verwendeten Exporte in dem gebuildeten Programmcode benötigt werden.
Die ausgewählten JavaScript Repositories sollten  für eine möglichst große Anzahl an Entwicklern und Entwicklerinnen von relevanter Bedeutung sein. Für die Auswahl werden daher jene NPM Module verwendet, welche am häufigsten in Webprojekten verwendeten werden. Es existiert bereits eine generische Liste \footnote{https://www.npmjs.com/browse/depended - besucht am 06.06.2018} die diese Module beinhaltet.

Auf NPM befinden sich neben Bibliotheken welche ES6 verwenden, auch welche die für NodeJS entwicklert wurden. Dabei werden der NodeJS Module verwendet und sind daher für diese Arbeit nicht geeignet \autocite{NodeJSModules}. Ein weiteres Kriterium für die Auswahl der zu untersuchenden Projekte ist daher die Verwendung von ES6 Modulen.
Anhand dieser Auswahlkriterien wurde folgende drei Projekte ermittelt, welche Tree Shaking und ES6  implementieren:

\begin{itemize}
	\item{lodash\footnote{https://github.com/lodash/lodash/tree/es - besucht am 15.06.2018}}
	\item{vue\footnote{https://github.com/vuejs/vue - besucht am 15.06.2018}}
	\item{graphql\footnote{https://github.com/graphql/graphql-js - besucht am 15.06.2018}}
\end{itemize}

\textbf{Implementierung von Tree Shaking}

In den ausgewählten Repositories wurde Tree Shaking mit \lstinline{SideEffects: false} in der pakage.json Datei aktiviert. Somit werden bei der Verwendung Named Imports wie zum Beispiel \lstinline|import {add} from 'lodash'|, diese aufgelöst zu \lstinline{import add from 'lodash/add'}. In der weiteren Folge wird sämtlicher nicht genutzter Programmcode der Libary entfernt und nur die verwendeten Module in die Bundle Datei integriert.

Webpack startet mit der Erzeugung des Bundles bei dem definierten Entry Point. In den untersuchten Repositories dient diese Datei, um die gewünschten Funktionalitäten nach außen zu exportieren. Wie bereits im Kapitel \ref{subsubsection:side_effects} festgestellt wurde können mögliche Sideeffects in dieser Datei entfernt werden. In allen drei Fällen werden daher lediglich \lstinline{import} und \lstinline{export} verwendet.

Da Programmcode außerhalb des benötigten Moduls nicht garantiert in der Bundle Datei enthalten ist, wurde der gesamte Sourcecode in für sich eigenständige Module aufgeteilt. Dies bedeudet, dass Module wie zum Beispiel \lstinline{add.js} alle Resourcen, welche für die ordnungsgemäße Funktionalität benötigt werden, importieren müssen.

\subsubsection{Best Practices zur Vermeidung von SideEffects}

Anhand der Untersuchten Eigenschaften und Libaries wurden die folgenden Annahmen in Bezug zur Vermeidung von Side Effects ermittelt, diese werden bei der Implementierung berücksichtigt und am Ende diese Arbeit auf ihre Wirksamkeit überprüft.

\begin{itemize}
\item Besitzt ein Modul Named Exports ist darauf zu achten, dass auf diese keine SideEffects wirken.
\item Bei der Verwendung eines Default Exports wird die Gesamte Datei eingebunden. Jegliche Side Effects innerhalb der Datei werden somit inkludiert.
\item Importe welche den Body eines Moduls ausführen werden von \textcite{Rauschmayer2018} als Empty Imports bezeichnet, können beim bündlen entfernt werden und müssen deshalb als SideEffect in der \lstinline{package.json} Datei vermerkt werden.
\item Der Entry Point einer Libary sollte für sich eigenständige Module importieren und diese als Named Exports zur Verfügung stellen. Dieser sollte keine SideEffects beinhalten.
\end{itemize}

\section{Linting}
Der Begriff Lint wurde erstmals in den 1970er in Verbindung mit der Softwareentwicklung erwähnt. \textcite{Johnson1978} entwicklete es an den Bell Laboratories um die Schwächen der damaligen C Compiler auszugleichen und undendteckte Fehlerin bereits kompilierten Programmen zu finden.

Es existieren viele Wege um die Anzahl an Bugs innerhalb einer Anwendung zu minimieren. Neben dem schreiben von Unit Tests, bieten Code Reviews laut \textcite{Louridas2006} wohl die beste Möglichkeit Bugs und Code Smells aufzufinden und zu eliminieren. Es fordert jedoch einen großen Zeitaufwand mehrere Entwickler zusammenzubringen und die gesamte Codebasis einer Anwendung gemeinsam zu reviewen.

Die meisten Fehler fallen in die Kategorie Known Errors. Dies sind häufig auftretende sich wiederholende Fälle in dennen die Entwickler und Entwicklerinnen immer wieder hinnenstoplern. Mit Linting möchte man die sich ständig wiederholenden Fehler oder auch Code Smells so früh es möglich ist finden und ausbessern. \autocite{Louridas2006}

Im Gegensatz zu einem Compiler muss beim Linting der Code nicht ausgeführt werden. So genannte Static Checker durchlaufen den Programmcode auf der Suche nach bestimmten Mustern, diesen Prozess wird als Statische Code Analyse bezeichnet. \autocite{Louridas2006}

Es gibt verschiedene Wege um eine Statische Code Analyse durchzuführen. Wie zum Beispiel auf Anfrage eines Entwicklers oder einer Entwicklerin, kontinuierlich wärend der Erstellung einer Anwendung oder aber direkt bevor ein Entiwckler oder eine Entwicklerin Codeänderungen auf ein Repository comittet will. Je nach Projekt können somit Fehler entdeckt und behoben werden bevor diese in der Codebasis am Repository landen.\autocite{Johnson}

Es exisitiert bereits reichlich Literatur zur Statischen Code Analyse. Dabei wurden nicht nur Aspekte wie Performance und Genauigkeit untersucht \autocite{Bessey2010}, sondern auch verschiedene Einsatzgebiete gezeigt \autocite{Bush}.

\textcite{Johnson} erforschten in ihrer Arbeit den Gebrauch und die Verbreitung von Statische Analyse Tools. Ein Teil davon war die Ermittlung was Entwickler und Entwicklerinnen als bei dem Gebrauch diese Werkzeuge als störend empfinden. Ergebnis davon war der nicht zu unterschätzende Anteil an false postives, sprich die Anzahl an Warnungen die keine wirklichen Fehler sind. Im weiteren wurde auch noch die hohe Arbeitslast von Entwicklern und Entwicklerinnen genannt. Laut \textcite{Johnson} sollten zukünftige Tools, sowohl eine besser Integration in den Arbeitsabläufen von Entwicklern und Entwicklerinnen bieten, als auch die Arbeit in einem Team besser unterstüzen.

\textcite{Bush} implementierte ein statisches Analyse Tool zum auffinden von dynamischen Fehler in C und C++. Dazu zählen unter anderem die Verwendung von nicht intitialisierten Speicher oder falschen Operation auf Dateien (zum Beispiel das Schließen einer Datei die bereit geschloßen wurde). Das aus der Arbeit entstandene Tool wurde PREFix getauft. Zur Analyse von Code wird der Abstract Syntax Tree generiert und anschließend die Funktionsaufrufe mittels eines Topolischen Algorithmus sortiert. Die Funktionen werden daraufhin simuliert und darin befindliche Defekte gemeldet. Als Teil dieser Arbeit wird ein Plugin erstellt, welches wie bei \textcite{Bush} den Abstract Syntax Tree auf ähnliche Art und weise untersucht. Jedoch soll dies für die Programmiersprache JavaScript erfolgen und sich lediglich auf fehlerhafte Muster in der Verwendung von ES6 Imports und Exports fokussieren.

\subsection{ES Lint}
2013 erschuff der Entwickler Nicholas C. Zakas ESLint. Ein Erweiterbares Linting Tool für JavaScript und JSX. Neben vielen bereits vorhandenen Linting Regeln bietet  ES Lint eine Möglichkeit für Entwickler und Entwicklerinnen solche auch selbst zu implementieren. Durch hinzufügen oder entfernen von Regeln wird der Linting Process je nach Projekt und Team konfiguriert. Dabei gilt für jede Regel die folgenden drei Grundsätze:
\begin{itemize}
  \item Jede Regel sollte Eigenständig funktionieren
  \item Bietet eine Möglichkeit zum An und Abschalten (nicht darf als zu wichtig zum deaktivieren gelten)
  \item Es kann zwischen Warnung und Fehler gewechselt werden
\end{itemize}
Um nicht jede Regel einzeln zu importieren gibt es ebenfalls die Möglichkeit mehrere Regeln als Bundle auszuliefern. \autocite{ESLintAbout}

Ziel dieser Arbeit ist es bereits implementierte Regeln für die Optimierung von ES6 Exports und Imports zu identifizieren und diese zu einem Bundle zusammenzufügen. Des weiteren werden ebenfalls eigene Regeln für ESLint erstellt, welche weitere schlechte Muster im Programmcode aufdeckt und auch Lösungen dafür anzeigt. \autocite{ESLintAbout}

(Kurzer Einleitungstext für die nächsten Kapitel)

\subsubsection{Core Rules}
\label{subsubsection:core_rules}

ESLint wird bereits mit mehr als 200 allgemein gültige Regeln ausgeliefert. Diese werden als Core Regeln bezeichnet. Gemäß \autocite{ESLintNewRules} muss eine eigene Regel die folgenden 6 Eigenschaften erfüllen um diese der Core Liste hinzuzufügen:

\textbf{1. Allgemeine Anwendbarkeit}
Core Regeln sollten relevant für eine große Anzahl an Entwickler und Entwicklerinnen sein. Regeln für Individuelle Präferenzen oder Edge Cases werden nicht akzeptiert.

\textbf{2. Generisch}
Neue Regeln sollten möglichst generisch sein. Ein Benutzer oder eine Benutzerin darf kein Poblem haben zu verstehen wann diese zu benutzen ist. Als Richtlinie gilt eine Regel ist zu spezifisch wenn man zur Beschreibung was sie macht mehr als zwei "und" benötigt. (zum Beispiel: Wenn a und b und c und d, dann wird der Benutzer oder die Benutzerin gewarnt)

\textbf{3. Atomar}
Regeln sollten vollkommen selbstständig funktionieren. Abhängikeiten zwischen zwei oder mehreren Regeln sind nicht erlaubt.

\textbf{4. Einzigartig}
Überschneidung zwischen Regeln sind ebenfalls nicht erlaubt. Jede sollte eine eigenen Warunug erzeugen. Somit wird der Benutzer nicht unnötig verwirrt.

\textbf{5. Unabhängig}
Regeln dürfen nur auf der JavaScript Laufzeitumgebung basieren und unabhängig von Libaries oder Frameworks sein. Core Regeln sollten stehts anwendbar sein und nicht davon abhängen ob spezielle Libaries wie JQuery verwendet werden. Hingegen existieren bereits einige Regeln die nur angewendet werden wenn die Laufzeitumgebung NodeJS vorhanden ist.

\textbf{6. Ohne Konflikte}
Keine Regel sollte sich mit anderen Regeln überschneiden. Zum Beispiel gibt es eine Regel, welche von einem Entwickler oder eioner Entwicklerin verlang jedes Statement mit einem Semikolon zu beenden. Es ist nicht erlaubt eine neue Regel zu entwerfen, die Semikolons verbietet. Statt dessen existiert die Regel Semi, diese kann beides und kann mit Hilfe der Konfiguration gesteuert werden.

(ich mache keine core regeln wegen dem 1. punkt - die anderen Eigenschaften sollten jedoch erfüllt werden)

https://eslint.org/docs/developer-guide/working-with-rules

(Runtime Rules vs Core Rules)

\subsubsection{Komponenten eines Plugins}
https://eslint.org/docs/developer-guide/working-with-plugins
(kurze einleitung  danach wie wird das in meinem plugin verwendet?)
\textbf{Rules}
\textbf{Environments}
\textbf{Configs}
\textbf{Processors}

\subsubsection{How to use}
Client config verwendung

\subsubsection{Formatters}
https://eslint.org/docs/user-guide/formatters/

\section{Erstellen des Plugins}
\subsection{Setup}
Um die Projektstruktur aufzusetzen verwende ich die von \textcite{ESLintNewRules} empfohlene Vorgehensweise. Ein wichtige Voraussetzung um ein ES Lint PLugin zu erstellen sind NPM und NodeJS, diese müssen zuerst installiert werden. In dieser Arbeit wird NodeJS v8.0.0 und NPM 5.8.0 verwendet.

Des weiteren wird das Commandline Tool Yeoman benötigt. Die aktuellste Version ist 2.0.2, diese wird mit dem Befehl \lstinline{npm install -g yo} global installiert und steht somit in der Konsole an jedem Ort zur Verfügung. Zuletzt wird das NPM Modul eslint-generator installiert es dient dazu ein leeres Gerüst für den Plugin Code zu erstellen.

Nach der Installation wird mit dem Befehl \lstinline{yo eslint:plugin} der Generator gestartet. Folgende Daten wurden dabei angegeben:
\begin{itemize}
	\item \textbf{Name:} silltho
    \item \textbf{Plugin-Id:} threeshaking
    \item \textbf{Beschreibung:} Webpack Tree Shaking Support
    \item \textbf{Werden Benutzerdefinierte Regeln verwendet?:} Ja
    \item \textbf{Werden Processors verwendet?:} Nein
\end{itemize}

Die daraus resultierende package.json Datei sieht wie folgt aus:

\begin{lstlisting}[
    label=listing:package.json,
	caption=generierte package.json Datei,
	language=JavaScript,
]
{
  "name": "eslint-plugin-treeshaking",
  "version": "0.0.0",
  "description": "Webpack Tree Shaking Support",
  "keywords": [
    "eslint",
    "eslintplugin",
    "eslint-plugin"
  ],
  "author": "silltho",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha tests --recursive"
  },
  "dependencies": {
    "requireindex": "~1.1.0"
  },
  "devDependencies": {
    "eslint": "~3.9.1",
    "mocha": "^3.1.2"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "license": "ISC"
}
\end{lstlisting}

In weiterer Folge wurde neben der \lstinline{README.md} Datei auch ein \lstinline{lib} und \lstinline{tests} Ordner im Projektverzeichnis erstellt. Der Ordner \lstinline{lib/rules} wird später den Programmcode für die neu erstellten Regeln beinhalten.

\subsection{Entwicklungsumgebung}
Für die Programmierung wird die integrierte Entwicklungsumgebung (IDE) WebStorm von JetBrains in der Version 2018.1.2 verwendet. Um Zeitpunkt dieser Arbeit ist die aktuellste verfügbare ESLint Version 4.19.1. In weitere Folge wird Prettier\footnote{https://prettier.io/ - besucht am 04.07.2018} für die Code Formatierung genutzt. Anschließend wurde noch Husky\footnote{https://github.com/typicode/husky - besucht am 04.07.2018} verwendet um Git Hooks für Prettier und die Teste Suite zu registrieren.


\section{Die Implementierung neuer Regeln}
Yeoman und der ESLint-Generator unterstützen Entwickler und Entwicklerinnen nicht nur beim Erzeugen der Projektdateiendateien sondern ebenfalls bei dem Anlegen neuer Regeln innerhalb des Plugins. Die dafür nötigen Dateien werden mit dem Befehl \lstinline{yo eslint:rule} erzeugt. Die neu erstellten Regeln innerhalb des Plugins sollen die Aufmerksamkeit von Entwickler und Entwicklerinnen auf die Probleme aus \ref{section:schwierigkeiten_beim_tree_shaking} richten und Wege aufzeigen um diese zu vermeiden. In diesem Kapitel wird dokumentiert wie die Regeln erstellt wurden. 

Beim Aufruf des Generators mit \lstinline{yo eslint:rule} müssen mehrere Fragen beantwortet werden:

\begin{itemize}
	\item What is your name?
    \item Where will this rule be published?
    \item What is the rule ID?
    \item Type a short description of this rule
    \item Type a short example of the code that will fail
\end{itemize}

In dieser Arbeit wird als Name silltho verwendet. Für den Publishing Ort kann zwischen ESLint Core und ESLint Plugin gewählt werden. Wie bereits im Kapitel \ref{subsubsection:core_rules} beschrieben wurde, eignen sich die in dieser Arbeit erstellten Regeln nicht als Core Regeln, es wird somit bei allen Regeln die Option ESLint Plugin gewählt. 

Alle weiteren Fragen können je nach Regel unterschiedlich beantwortet. In weiterer Folge werden diese als Tabelle bei der Implementierung jeder Regel dargestellt.

Vom Generator werden abschließend die folgenden Dateien im Projektverzeichnis erzeugt:
\begin{itemize}
	\item \textbf{docs/rules/(rule-id).md} - Dokumentation der Regel und der Konfiguration Möglichkeiten.
    \item \textbf{lib/rules/(rule-id).js} - Programmcode.
    \item \textbf{tests/lib/rules/(rule-id).js} - Tests um sicherzustellen das die Regel wie gewünscht funktioniert.
\end{itemize}

Die nachfolgenden Kapitel beschreiben die Implementierung der Regeln die benötigt werden um Code Smells beim Tree Shaking für Entwickler und Entwicklerinnen anzuzeigen.

\subsection{Empty Imports}

\begin{table}[H]
\centering
\caption{Yeoman Generator: Empty Imports}
\label{tbl:empty_imports}
\begin{tabular}{|l|l|}
\hline
Rule-ID: & no-empty-imports \\ \hline
Beschreibung: & disallow Empty Imports \\ \hline
\end{tabular}
\end{table}

Gemäß den Erkenntnissen aus  Kapitel\ref{subsection:side_effects}, müssen Empty Imports wie zum Beispiel \lstinline{import 'module1'} als Side effect gekennzeichnet werden. Diese werden sonst beim bündeln des Programmcodes als Unused Imports erkannt und entfernt. Ziel dieser Regel ist es die Aufmerksamkeit von Entwicklern und Entwicklerinnen auf diese Art von Imports zu richten und sie daran zu erinnern diese in der  \lstinline{package.json} Datei als SideEffect zu vermerken.

Um diese Funktionsweise zu gewährleisten wurden folgende Test Datei \lstinline{test/lib/rules/empty-imports.js} erstellt: 

\begin{lstlisting}[
    label=listing:empty_import_test,
	caption=Empty Imports Unit Tests,
	language=JavaScript,
]
var ruleTester = new RuleTester();
ruleTester.run("empty-imports", rule, {

    valid: [
      {
        options: [['empty-import']],
        code: `
          import 'empty-import'
          import lib1 from 'lib1'
          export const export1 = 'export1'
          export default 'default'
        `,
        errors: []
      },
      {
        options: [],
        code: `
          import name from "module-name";
          import * as name2 from "module-name";
          import { member } from "module-name";
          import { member as alias } from "module-name";
          import { member1 , member2 } from "module-name";
          import { member3 , member2 as alias2 } from "module-name";
          import defaultMember, { member4 } from "module-name";
          import defaultMember2, * as alias3 from "module-name";
          import defaultMember3 from "module-name";
        `,
        errors: []
      }
    ],

    invalid: [
        {
            code: `
                import 'empty-import'
                import lib1 from 'lib1'
                export const export1 = 'export1'
                export default 'default'
            `,
            errors: [{
                message: 'empty imports are removed by tree shaking. Make sure you add empty-import to package.json sideEffects option.',
                type: 'ImportDeclaration'
            }]
        }
    ]
});
\end{lstlisting}

Als ersten Schritt werden mit dem AstExplorer \footcite{https://astexplorer.net/ - besucht am 26.06.2018} die 
verschiedenen Import Nodes aus dem Kapitel \ref{subsubsection:Syntax} analysiert. Der NodeType für Importe in ES6 ist \lstinline{ImportDeclaration}. In weiterer folge konnte festgestellt werden, dass Empty Import Nodes keine specifier besitzen, somit ist \lstinline{importNode.specifiers.length === 0} true, falls es sich um einen Empty Import handelt. Mit Hilfe dieser Erkenntnisse ist es bereits möglich Empty Imports aufzuspüren und zu kennzeichnen.

\begin{lstlisting}[
    label=listing:empty_import_rule_1,
	caption=Code zum Aufspüren von Empty Imports,
	language=JavaScript,
]
        function isEmptyImport(importNode) {
            if(importNode.specifiers.length === 0) {
              reportEmptyImport(importNode)
            }
        }

        return {
          'ImportDeclaration': isEmptyImport
        };
\end{lstlisting}

Nach der Implementiern von Listing \ref{empty_import_rule_1} werden zwei der drei Tests bereits erfolgreich durchgeführt.  Beim ersten validen Test wird jedoch der Fehler \lstinline{AssertionError [ERR_ASSERTION]: Should have no errors but had 1} angezeigt. Empty Imports können in der \lstinline{package.json} Datei als SideEffects vermerkt werden. Diese werden anschließend im Programmcode inkludiert und können verwendet werden. Die Empty Imports Regel sollte dahingehend konfigurierbar sein.

Hierfür sollte man als Option ein Array von Pfaden und Glob Pattern übergeben, gleich zu der SideEffects Einstellung von Webpack. \textcite{WebpackTreeShaking} zeigt, dass für die Auflösung der SideEffect Property die Bibliothek Micromatch \footnote{https://github.com/micromatch/micromatch - besucht am 26.06.2018} verwendet wird. Für die Auflösung der Array Daten innerhalb der Regel wird die selbe Libary verwendet, um die Unterschiede zwischen Webpack und Regel Konfiguration möglichst gering zu halten.

Damit die Empty Imports Regel ein Array von Strings als Property akzepiert muss die Schema Konfiguration in \lstinline{lib/rules/empty-imports.js} wie folgt angepasst werden:

\begin{lstlisting}[
    label=listing:empty_import_rule_2,
	caption=Empty Import Option Schema,
	language=JavaScript,
]
      schema: [
        {
          type: 'array'
        }]
    }
\end{lstlisting}

Anschließend kann auf die Konfiguration mittels \lstinline{context.options[0]} zugegriffen werden.

\begin{lstlisting}[
    label=listing:empty_import_rule_3,
	caption=isKnownSideEffect Funktion,
	language=JavaScript,
]
        function isKnownSideEffect(emptyImportNode) {
          return mm.any(emptyImportNode.source.value, knownSideEffects, null)
        }
\end{lstlisting}

In weiterer Folge wird eine zusätzliche Funktion \lstinline{isKnownSideEffect} implementiert. Diese vergleicht den Value eines Imports mit den übergebenen Array. Micromatch bietet dafür die Methode \lstinline{any(str, patterns, options)} an. Diese vergleicht den übergebenen String mit dem Patternsarray und liefert true falls ein beliebiges Pattern in dem Array mit dem String übereinstimmt.

Zuletzt muss noch die isEmptyImport angepasst werden, um mit der neuen Funktion alle Empty Imports zu überprüfen.

\begin{lstlisting}[
    label=listing:empty_import_rule_3,
	caption=isKnownSideEffect Funktion,
	language=JavaScript,
]
        function isEmptyImport(importNode) {
            if(importNode.specifiers.length === 0 && !isKnownSideEffect(importNode)) {
              reportEmptyImport(importNode)
            }
        }
\end{lstlisting}

Beim erneuten Ausführen der Tests werden alle erfolgreich abgeschloßen. Die Regel ist somit erfolgreich Implementiert und wird am Ende dieser Arbeit auf ihre Wirksamkeit geprüft.

\subsection{Named Exports SideEffects}

\begin{table}[H]
\centering
\caption{Yeoman Generator: Named Exports SideEffects}
\label{tbl:empty_imports}
\begin{tabular}{|l|l|}
\hline
Rule-ID: & no-named-exports-sideeffects \\ \hline
Beschreibung: & disallow SideEffects onto Named Exports \\ \hline
\end{tabular}
\end{table}

Ein weiterer Code Smell aus Kapitel \ref{subsection:side_effects} ist der Gebrauch von SideEffects auf Named Exports.

\begin{lstlisting}[
    label=listing:counter.js,
	caption=counter.js,
	language=JavaScript,
]
let counter = 1

const incCounter = (newValue) => {
	counter++
}

export {
	incCounter,
	counter
}
\end{lstlisting}

\begin{lstlisting}[
    label=listing:named_exports_sideeffects_rule_1,
	caption=lib.js,
	language=JavaScript,
]
	import { counter, incCounter } from "counter";
	incCounter();
	export { counter }
\end{lstlisting}

\begin{lstlisting}[
    label=listing:named_exports_sideeffects_rule_2,
	caption=index.js,
	language=JavaScript,
]
	import { counter } from "lib";
	console.log(counter) // 1
\end{lstlisting}

Listing \ref{listing:counter.js}, \ref{listing:named_exports_sideeffects_rule_1} und \ref{listing:named_exports_sideeffects_rule_2} zeigen ein Beispiel für einen solchen SideEffect. Obwohl die Methode \lstinline{incCounter} in \lstinline{lib.js} aufgerufen wird, wird durch Tree Shaking \lstinline|import { counter } from "lib"| zu \lstinline|import { counter } from "counter"|. Somit wird die Datei \lstinline{lib.js} nicht inkludiert und auch der \lstinline{incCounter} Aufruf geht in weiterer Folge verloren.

Für die Implementierung werden Imports (\lstinline{import}), Named Exports  (\lstinline{export}) und Expressions (\lstinline{incCounter} oder \lstinline{counter.test = '123'}) benötigt. Mit dem ASTexplorer wurden erneut die dem entsprechenden Node Typen ImportDeclaration, ExportNamedDeclaration und ExpressionStatement ermittelt.

Die folgende Test Datei, soll die Funktionsfähigkeit der Regel sicherstellen. Insgesamt wurden 4 valide und 4 invalide Szenarien ausgearbeitet.

\begin{lstlisting}[
    label=listing:named_exports_sideeffects_test,
	caption=Named Exports SideEffects Unit Tests,
	language=JavaScript,
]
var ruleTester = new RuleTester()
ruleTester.run('named-exports-sideeffects', rule, {
  valid: [
    {
      options: [],
      code: `
          import name from "module-name";
          import name2 from "module-name2";
          name2.sideeffect = 'sideeffect'
          export {
            name
          }
          export default name2
        `,
      errors: []
    },
    {
      options: [],
      code: `
          testFunction = () => {
            console.log('test')
          }
          export {
            testFunction
          }
        `,
      errors: []
    },
    {
      options: [],
      code: `
          import name from "module-name";
          import name2 from "module-name2";
          console.log('test123')
          export default name2
        `,
      errors: []
    },
    {
      options: [],
      code: `
          import name from "module-name";
          import name2 from "module-name2";
          const tmp = 'tmp'
          export {
            tmp as name,
            name as name2
          }
        `,
      errors: []
    }
  ],

  invalid: [
    {
      options: [],
      code: `
            import test2 from "module-name2";
            test2.sideeffect = 'sideeffect'
            export { test2 }
    `,
      errors: [
        {
          message:
            'Effects on reexported modules (test2) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: [],
      code: `
          import test2 from "module-name2";
          test2.init('initSomeThing')
          export { test2 }
        `,
      errors: [
        {
          message:
            'Effects on reexported modules (test2) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: [],
      code: `
          import { counter as temp1, incCounter as temp2 } from "module-name2";
          temp2();
          export { temp1 as tmp }
        `,
      errors: [
        {
          message:
            'Effects on reexported modules (temp1) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: [],
      code: `
          import { counter, incCounter } from "module-name2";
          incCounter();
          export { counter }
        `,
      errors: [
        {
          message:
            'Effects on reexported modules (counter) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    }
  ]
})

\end{lstlisting}

Die invaliden Testfälle aus Listing \ref{listing:named_exports_sideeffects_test} können in zwei Kategorien eingeteilt werden. Zum einen direkte SideEffects wie zum Beispiel \lstinline{test2.init('initSomeThing')}. Dieser wirkt direkt auf das zuvor importierte \lstinline{test2} Modul, welches anschließend als Named Export exportiert wird. Die zweite Kategorie werden in dieser Arbeit als indirekte SideEffects bezeichnet. Ein Beipiel dafür ist der Aufruf der Methode \lstinline{incCounter()} in Listing \ref{listing:named_exports_sideeffects_rule_1}. Dieser hat Auswirkungen auf den Export von \lstinline{counter}. Da die Variable \lstinline{counter} jedoch nie verwendet oder verändert wird, sind diese wesentlich schwerer zu erkennen als direkte Side Effects. 

Für die Erkennung der direkten Side Effects werden alle Imports und Named Exports in einem Array gespeichert. Dies geschieht mit der Hilfe des \lstinline{ImportDeclaration} und \lstinline{ExportNamedDeclaration} Node Selectors. Diese rufen die Funktionen \lstinline{saveImport}  und \lstinline{saveNamedExport} auf. Darin werden die einzelnen Specifier zu in Array gespeichert. Zum Beispiel bei folgenden Export \lstinline|export {test1, test2}| werden jeweils die Specifier Node \lstinline{test1} und \lstinline{test2} gespeichert. Als nächsten werden alle SideEffects mit dem \lstinline{ExpressionStatement} Selector und der Funktion \lstinline{saveExpression} ebenfalls in einem Array vermerkt. Schließlich kann mit dem Selector \lstinline{Program:exit} am Ende eines jeden Moduls, der Identifier jeder gespeicherten Expression mit den Named Exports und Imports verglichen werden und bei Überschneidungen diese Expression Node als SideEffect melden.
Somit werden SideEffects die direkt einen Named Export betreffen erkannt und eine entsprechende Warnung dem Benutzer oder der Benutzerin angezeigt.

Das Erkennen von indirekten SideEffects hingegen gestaltet sich komplizierter. Zuerst werden alle  Named Imports wie zum Beispiel \lstinline|import {counter, incCounter} from 'counter'| ebenfalls in einem Array gespeichert. Der dafür verwendete Node Selector ist \lstinline{ImportDeclaration}. 
Für indirekte SideEffects können entstehen wenn Importe mehrer Specifier besitzen. Als Beispiel die Import Specifier aus Listing \ref{listing:named_exports_sideeffects_rule_1} sind \lstinline{counter} und \lstinline{incCounter}, der Import deklariert also zwei Variablen aus dem selben Modul. Wenn nun eine der Expressions sich mit einem der Einträge in \lstinline{import} übereinstimmt und das Modul einen im selben Import befindlicher Specifier als Named Export exportiert, wird davon ausgegangen das es sich dabei um einen SideEffect handelt. Die entsprechende Expression Node wird somit reported und der Benutzer erhält einen Hinweis, dass dies zu ungewollten Effekten in seinem Programm führen kann.

Indirekte SideEffects wie \lstinline{incCounter()} aus Listing \ref{listing:named_exports_sideeffects_rule_1} werden somit zusätzlich zu den direkten SideEffects erkannt und alle Tests werden erfolgreich abgeschloßen.


\subsection{Entry Point SideEffects}

\begin{table}[H]
\centering
\caption{Yeoman Generator: Entry Point SideEffects}
\label{tbl:sideeffects}
\begin{tabular}{|l|l|}
\hline
Rule-ID: & no-entry-point-sideeffects \\ \hline
Beschreibung: & disallow SideEffects in the Entry Point \\ \hline
\end{tabular}
\end{table}

Die Startdatei oder Entry Point einer JavaScript Libary ist ein wichtiger Bestandteil für die Effektivität von Tree Shaking.

\begin{lstlisting}[
    label=listing:entry_point_sideeffects_test,
	caption=Entry Point SideEffects Unit Tests,
	language=JavaScript,
]
var ruleTester = new RuleTester()
ruleTester.run('entry-point-sideeffects', rule, {
  valid: [
    {
      options: [],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        console.log('sideeffect')
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: []
    },
    {
      options: [],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        module.test = 'tmp'
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: []
    },
    {
      options: [],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        console.log('test')
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: []
    }
  ],

  invalid: [
    {
      options: ['**/src/entry.js'],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        module.test = 'tmp'
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: [
        {
          message: 'Sideeffects in the entry-point are not allowed.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: ['**/src/entry.js'],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        console.log('test')
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: [
        {
          message: 'Sideeffects in the entry-point are not allowed.',
          type: 'ExpressionStatement'
        }
      ]
    }
  ]
})
\end{lstlisting}

Die Regel soll, jede Node im Entry Point bei der es sich weder um einen Import noch einen Export handelt, für Entwickler  und Entwicklerinnen eine Meldung anzeigen. Für die Implementierung werden die Node Types \lstinline{ImportDeclaration}, \lstinline{ExportNamedDeclaration}, \lstinline{ExportDefaultDeclaration}, \lstinline{ExportAllDeclaration} und \lstinline{Program} benötigt. In weiterer Folge wird zusätzlich der \lstinline{:not} Selector verwendet. Eine Beischreibung dazu lieferte der ESLint Selector Guide\footnote{https://eslint.org/docs/developer-guide/selectors - besucht am 29.06.2018}. Der gesamte Selector um alle möglichen SideEffects in einem Modul zu finden ist: \lstinline{Program > :not(ImportDeclaration, ExportNamedDeclaration, ExportDefaultDeclaration, ExportAllDeclaration)}.

Anschließend muss noch überprüft werden, ob es sich bei dem aktuellen Modul, um den Entry Point handelt. Der Benutzer oder die Benutzerin kann dies durch eine Option steuern. Die Entry Point SideEffects Regel erwartet als Parameter einen Golb Pattern String. Dieser diehnt dazu den Entry Point festzulegen. Nur dieser soll absolut frei von SideEffects sein und darf lediglich Importe und Exporte Deklarationen beinhalten.

\section{Testen des Plugins}

Um die Funktionsweise des Plugins \lstinline{eslint-plugin-treeshaking} zu überprüfen wird eine Testreihe mit JavaScript Repositories von Github\footnote{https://github.com/ - besucht am 07.07.2018} durchgeführt. Als Test Subjekte werden, sowohl Bibliotheken welche bereits Tree Shaking unterstützen, als auch welche die nicht darauf optimiert wurden benötigt. In dem Kapitel \ref{subsubsection:untersuchung_von_js_libs} wurden bereits drei Repositories mit der \lstinline{sideEffects: false} Konfiguration ermittelt, diese werden für die Testreihe erneut verwendet. Die drei nicht in Bezug auf Tree Shaking optimierte Bibliotheken werden der selben Liste\footnote{https://www.npmjs.com/browse/depended - besucht am 06.06.2018} entnommen. 

\paragraph{Tree Shaking optimiert:}
\begin{itemize}
\item graphql-js\footnote{https://github.com/graphql/graphql-js - besucht am 15.06.2018} 
\item vue\footnote{https://github.com/vuejs/vue - besucht am 15.06.2018} 
\item lodash\footnote{https://github.com/lodash/lodash - besucht am 15.06.2018}
\end{itemize}

\paragraph{kein Tree Shaking}
\begin{itemize}
\item d3\footnote{https://github.com/d3/d3 - besucht am 08.07.2018}
\item immutable-js\footnote{https://github.com/facebook/immutable-js - besucht am 08.07.2018}
\item moment\footnote{https://github.com/moment/moment - besucht am 15.06.2018}
\end{itemize}

\subsection{Aufbau}

Für die Durchführung der Tests wird von allen Testsubjekten mit dem \lstinline{git clone} Befehl eine lokale Arbeitskopie angelegt. In weitere Folge wird ESLint benötigt. In allen Repositories muss eine statische Code Analyse mit dem Tree Shaking Plugin durchgeführt werden. Am besten ist dies möglich mit dem Tool  ESLint-CLI\footnote{https://github.com/eslint/eslint-cli - besucht am 09.07.2018}. Dies ermöglicht die Tests direkt mittels Konsoleneingabe zu starten und wird mit dem Befehl \lstinline{npm install -g eslint-cli} global installiert.

\begin{lstlisting}[
    label=listing:eslintrc,
	caption=Beispiel für eine Test Konfiguration,
	language=JavaScript,
]
{
  "env": {
    "browser": true,
    "es6": true
  },
  "parserOptions": {
    "sourceType": "module"
  },
  "plugins": ["treeshaking"],
  "rules": {
    "treeshaking/no-empty-imports": ["warn",["*.css"]],
    "treeshaking/no-named-exports-sideeffects": "warn",
    "treeshaking/no-entry-point-sideeffects": ["warn", "index.js"]
  }
}
\end{lstlisting}

Für die Konfiguration der Analyse wird eine \lstinline{.eslintrc} Datei verwendet. Listing \ref{listing:eslintrc} zeigt ein Beispiel für diese Datei. Zwischen den verschiedenen Repositories ist es nötig die Optionen bei den drei aktivierten Regeln anzupassen.

Eine weitere Abhängigkeit ist das Tree Shaking Plugin\footnote{https://github.com/silltho/eslint-plugin-treeshaking}. Dieses wird durch den Befehl \lstinline{npm install git+ssh://git@github.com/silltho/eslint-plugin-treeshaking.git} installiert. Auch ESLint muss als Projektinteres Modul zur Verfügung stehen. Der Befehl \lstinline{npm install eslint} wird also ebenfalls in jeden Repository ausgeführt.

Sollte eine Libary bereits ESLint verwenden, werden alle Abhängigkeiten mit \lstinline{npm install} installiert. Anschließend wird eine Analyse ohne jegliche Anpassungen durchgeführt. Dadurch werden bereits bekannte Warnungen oder Probleme ermittelt und können von den Ergebnissen ausgeschloßen werden. Zuletzt  wird die bereits bestehende Konfiguration um das Tree Shaking Plugin und die dazugehörigen drei Regeln erweitert und eine erneuter Analyse gestartet.

\subsection{Ablauf}

Für den Ablauf wird zuerst der Entry Point der zu Untersuchenden Bibliothek ermittelt. Der Einstiegspunkt für das Programm wird mit der Option \lstinline{main} in der \lstinline{package.json} Datei gesetzt. Dieser wird als Option für die Regel \lstinline{treeshaking/no-entry-point-sideeffects} benötigt.

Anschließend wird die \lstinline{.eslintrc} Datei, wie in Listing \ref{listing:eslintrc} gezeigt wurde, erstellt und die Optionen für das jeweilige Repository angepasst.

In weitere Folge muss ermittelt werden wo sich die Source Dateien der Bibliotheken befinden. Für den ESLint Befehl wird ein Glob Pattern benötigt, welches alle den gesamten Source Code abdeckt. Schließlich kann die Analyse mit dem Befehl \lstinline{eslint} durchgeführt werden. Für die Berichte werden die Optionen \lstinline{-o lint.html} und \lstinline{-f html} für eine Ausgabe als HTML Datei verwendet.

Sowohl die projektspezifischen ESLint Optionen, als auch der der Befehl zum durchführen der Tests werden als Tabelle bei den Ergebnissen mit präsentiert. 

\subsection{Ergebnisse}

\subsubsection{graphql-js}
\begin{table}[H]
\centering
\caption{ESLint Optionen für graphql-js}
\label{tbl:graphql-js-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "**/index.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html --rulesdir ./resources/lint}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html --rulesdir ./resources/lint}
\end{center}

GraphQL verwendet bereits ESLint und es existiert im Repository eine \lstinline{.eslintrc} Datei. Durch eine Analyse der in \lstinline{package.json} befindlichen Konfiguration, wird das Script \lstinline{"lint": "eslint --rulesdir ./resources/lint src || (printf '\\033[33mTry: \\033[7m npm run lint -- --fix \\033[0m\\n' && exit 1)"} zur durchführung einer statischen Analyse verwendet. \lstinline{--rulesdir ./resources/lint} definiert repository spezifische Regeln und muss für den Test adaptiert werden, um Fehler zu vermeiden. Die Konfiguration wurde in den Default Lint Befehl übernommen. Die daraus resultierende HTML Datei zeigt, dass sich keine bekannten Fehler im Repository befinden. Anschließend wurde das Tree Shaking Plugin mit den in der Tabelle \ref{tbl:graphql-js-options} ersichtlichen Regeln hinzugefügt. Auch hierbei wurden wie erhofft keine warnung oder Fehler angezeigt. Die GraphQl Bibliothek unterstützt Tree Shaking aus der Sicht des Plugins wie erwartet.

\subsubsection{vue}
\begin{table}[H]
\centering
\caption{ESLint Optionen für vue}
\label{tbl:vue-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "**/src/core/index.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html}
\end{center}

Im Vue Repository befindet sich bereits eine \lstinline{.eslintrc}. Somit muss zuerst ein Lint Bericht ohne dem Tree Shaking Plugin erstellt werden. Anders wie bei GraphQl gibt es jedoch keine Projektspezifische Konfiguration oder Regeln. Für die Erstellung des Prüfberichts musste der \lstinline{eslint} Befehl nicht angepasst werden und \lstinline{default.html} zeigte keine Projektinternen Fehler. Darauf folgend wurde die das Tree Shaking Plugin der Konfiguration hinzugefügt, die Optionen wie in der Tabelle \ref{tbl:vue-options} ersichtlich gesetzt und ein neuer Bericht erstellt.

\lstinline{lint.html} zeigt insgesamt 5 Warnung in Entry Point Datei \lstinline{src/core/index.js}. Alle zeigen die selbe Nachricht \lstinline{Sideeffects in the entry-point are not allowed.}.

\begin{lstlisting}[
    label=listing:vue_entry_point,
	caption=Vue Entry Point Datei (src/core/index.js),
	language=JavaScript,
]
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
import { isServerRendering } from 'core/util/env'
import { FunctionalRenderContext } from 'core/vdom/create-functional-component'

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

Vue.version = '__VERSION__'

export default Vue
\end{lstlisting}

Listing \ref{listing:vue_entry_point} zeigt die Entry Point Datei der Vue Libary. Diese besitzt wie das Tree Shaking Plugin anzeigt mehrere Side Effects. Wenn man den Code betrachtet wird ersichtlich das lediglich ein Default Export und keine Named Exports verwendet wird. Side Effects werden somit immer inkludiert und stellen keine Gefahr für die Funktionweise des exportierten Objekts. Jedoch ist es dadurch nicht möglich nur einzelne Teile der Vue Bibliothek zu verwenden. Sollte eine Warnung angezeigt werden, wenn der Entry Point nur einen Default Export anbietet? Sind Side Effects im Entry Point erlaubt, wenn nur ein Default export verwendet wird? Weitere Forschung wäre nötig ,um die daraus resultierenden Fragen zu klären und das Plugin dahingehenden zu erweitern. 

\subsubsection{lodash}
\begin{table}[H]
\centering
\caption{ESLint Optionen für lodash}
\label{tbl:lodash-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "lodash.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint *.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint *.js -o lint.html -f html}
\end{center}

Lodash verwendet ebenso wie GraphQL und Vue ESLint. Beim erstellen des Prüfberichts werden drei bereits bekannte Fehler angezeigt. \lstinline{Unable to resolve path to module './.internal/createFind.js'.} scheint ein Problem beim Auflösen von Pfaden zu sein. Diese werden voerst ignoriert und wieder wird das Tree Shaking Plugin hinzugefügt und die Optionen dem Repository angepasst. Bei der erneuten Durchführung der statischen Analyse werden die selben drei Fehler wie im Default Bericht angezeigt. Es konnten keine Warnungen in Bezug auf Tree Shaking gefunden werden.

\subsubsection{d3}
\begin{table}[H]
\centering
\caption{ESLint Optionen für d3}
\label{tbl:d3-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "index.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint *.js -o lint_default.html -f html} \linebreak 
\textbf{Lint Befehl:} \lstinline{eslint *.js -o lint.html -f html}
\end{center}

Die D3 Libary ist die erste, welche nicht die \lstinline{sideEffect} Option in der \lstinline{package.json} Datei verwendet. Tree Shaking wurde somit nicht aktiviert und unbenützter Code kann nicht entfernt werden. Das Tree Shaking Plugin soll Entwicklern und Entwicklerinnen dabei helfen dies zu ändern und Stellen aufdecken bei dennen Anpassungen nötig sind. D3 verwendet kein ESLint und besitzt auch keine \lstinline{.eslintrc} Datei. Deshalb wird für den Default Bericht diese Datei erstellt:

\begin{lstlisting}[
    label=listing:eslintrc_d3,
	caption=Default Konfiguration für die d3 Bibliothek,
	language=JavaScript,
]
{
  "env": {
    "browser": true,
    "es6": true
  },
  "parserOptions": {
    "sourceType": "module"
  },
  "plugins": [],
  "rules": {}
}
\end{lstlisting}

Der erstellte Bericht zeigt keine Fehler oder Warnungen im Repository. Nach dem Hinzufügen des Tree Shaking Plugins und seiner Konfiguration wird ein erneuter Lint Bericht \lstinline{lint.html} erstellt. Dieser zeigt ebenso keine Fehler oder Warnungen. Damit sollte die d3 Bibliothek bereits Tree Shaking unterstützen. Es fehlt lediglich die \lstinline{sideEffects: false} Einstellung in der \lstinline{package.json} Datei.

\subsubsection{immutable-js}
\begin{table}[H]
\centering
\caption{ESLint Optionen für immutable-js}
\label{tbl:immutable-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "src/Immutable.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html}
\end{center}

Wie bereits bei eingen Test Subjekten zuvor verwendet die Immutable-JS Bibliothek bereits ESLint und besitzt eine Konfigurations Datei. Nach installieren der dafür benötigten Abhängigkeiten wird ein erster Lint Bericht ohne die Verwendung des Tree Shaking Plugins, erstellt. Dabei treten weder Warnung noch Probleme auf. Beim Linting mit dem Tree Shaking Plugin werden 6 Warnungen in der Date \lstinline{src/CollectionImpl} gefunden. Alle sind vom Typ no-named-exports-sideeffects. Der von der Regel generierte Hinweis lautet: "Effects on reexported modules (Collection) could be prune by TreeShaking".

\begin{lstlisting}[
    label=listing:immutable_sideeffects,
	caption=immutable-js Warnungen (src/CollectionImpl),
	language=JavaScript,
]
	import {
		Collection,
		KeyedCollection,
		IndexedCollection,
		SetCollection,
	} from './Collection';

	// Note: all of these methods are deprecated.
	Collection.isIterable = isCollection;
	Collection.isKeyed = isKeyed;
	Collection.isIndexed = isIndexed;
	Collection.isAssociative = isAssociative;
	Collection.isOrdered = isOrdered;

	Collection.Iterator = Iterator;
	
	export {
  		Collection,
  		KeyedCollection,
  		IndexedCollection,
  		SetCollection,
  		CollectionPrototype,
  		IndexedCollectionPrototype,
	};
\end{lstlisting}

Der Programmcode in Listing \ref{listing:immutable_sideeffects} zeigt die von ESLint makierten Zeilen und die dazugehörigen Import und Export Deklarationen. Bei der Verwendung von Tree Shaking könnten die Zeilen 9 bis 15 unbeabsichtig entfernt werden. Weitere Nachforschungen sind nötig,
 ,um genauer festzustellen ob die vom Plugin makierten Zeilen auch wirklich zu Fehlern bei der Verwendung von \lstinline{Collection} führen. 

\subsubsection{moment}
\begin{table}[H]
\centering
\caption{ESLint Optionen für moment}
\label{tbl:moment-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "src/moment.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html}
\end{center}

Moment ist die letzte Javascript Bliobliothek die für die Überprüfung des Tree Shaking Plugins untersucht wird. Ebenso wie d3 und immutable-js ermöglicht Sie kein Tree Shaking. Ebenso wurde für die Entwicklung nicht ESLint verwendet. Somit wird eine \lstinline{.eslintrc} Datei ohne aktivierten Regeln erstellt und eine Analyse damit durchgeführt. Der resultierende Bericht zeigt keine Fehler  in den Source Dateien. Nach dem Hinzufügen der Tree Shaking Regeln wie in Tabelle \ref{moment-options} gezeigt, werden im Bericht insgesamt 19 Warnungen angezeigt. Diese betreffen vier Dateien und sind vom Typ no-empty-imports.

Die vier betroffenen Dateien sind:
\begin{itemize}
\item src/lib/duration/duration.js
\item src/lib/locale/en.js
\item src/lib/locale/locale.js
\item src/lib/units/units.js
\end{itemize}

\begin{lstlisting}[
    label=listing:moment_sideeffects,
	caption=moment Datei mit Warnungen (src/lib/duration/duration.js),
	language=JavaScript,
]
	import {
		Collection,
		KeyedCollection,
		IndexedCollection,
		SetCollection,
	} from './Collection';

	// Side effect imports
	import './prototype';

	import { createDuration } from './create';
	import { isDuration } from './constructor';
	import {
    		getSetRelativeTimeRounding,
    		getSetRelativeTimeThreshold
	} from './humanize';

	export {
    		createDuration,
    		isDuration,
    		getSetRelativeTimeRounding,
    		getSetRelativeTimeThreshold
	};
\end{lstlisting}

Listing \ref{listing:moment_sideeffects} zeigt in Zeile 9 einen Empty Import der die Warnung in dieser Datei verursacht. Er wurde bereits vorab von einem Entwickler oder einer Entwicklerin als Side Effect makiert. Die genaue Fehler Meldungen des Tree Shaking Plugins für diese Zeile lautet: "empty imports are removed by tree shaking. Make sure you add ./prototype to package.json sideEffects option". Durch die Verwendung eines Arrays von Strings statt false für die sideEffects Konfiguration, kann Webpack informiert werden diese Datei aufjedenfall mit einzubinden. Die dafür nötige Einstellung wäre \lstinline{sideEffects: ['prototype']}. Die no-empty-imports Regel bietet ebenso an dies durch eine Option zu konfigurieren. Es wird daher der Eintrag für no-empty-imports in der \lstinline{.eslintrc} Datei angepasst zu \lstinline{"treeshaking/no-empty-imports": ["warn", ["prototype"]]}. Ein erneuter Bericht wird erstellt und dieser zeigt die Warnung in der Datei aus Listing \ref{listing:moment_sideeffects} nicht an. Wiederum wären weitere Forschungen nötig ,um die richtige Funktionsweise von Tree Shaking an dieser Stelle genauer zu evaluieren.

\section{Zukünftige Arbeiten}

\section{Schlussfolgerung}

