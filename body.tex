\section{Einleitung}

Für Javascript Webentwickler ist das NPM Registry eines der wichtigsten Werkzeuge. Es bietet eine Plattform für Entwickler und Entwicklerinnen, um Sourcecode mit anderen Entwicklern und Entwicklerinnen zu teilen, bestehende Module herunterzuladen und in die eigene Anwendung zu integrieren. Seit dem Release wurden über 600.000 verschiedene Software Pakete hinzugefügt. Mit mehr als einer Millarde Downloads pro Woche ist das NPM Registry zu einer zentralen Bibliothek von Frameworks, Libraries und Werkzeugen für die Javascript Entwicklung geworden. \autocite{NpmDocs}

Die Anzahl der Module und deren komplexe Abhängigkeiten zueinander führten im Bereich der Frontendentwicklung zu fundamentalen Problemen. Neben der Dependency Hell, einem der wohl bekanntesten dieser Probleme, ist es entscheidend, die an den Browser zu übertragende Datenmenge möglichst gering zu halten. Um dies zu erreichen, müssen die Entwickler und die Entwicklerinnen unnötige Versions Duplikate und unerreichbare Zweige im Programmcode vermeiden.\autocite{DominikWilkowski}

Die benötigte Datenmenge einer Website hat einen negativen Effekt auf die Antwortzeit für Benutzer und Benutzerinnen. Es existiert bereits reichlich Literatur zu den Auswirkungen der Downloadzeit zur Nutzerzufriedenheit. Bereits 1997 erkannte \textcite{Nielson1997} die Bedeutung der Lade Geschwindigkeit einer Website auf die \textit{User Experience}. In den 90er Jahren waren die Größe von Bilder einer der Hauptgründe für eine schlechte Performance. Mehr als 10 Jahre später ist die Auswirkung der Bildergröße auf die Ladezeit aufgrund der allgemein schnelleren Internetverbindungen nicht mehr so schwerwiegend. Auch wenn sich die Gründe für eine langsame Websites verändert haben, bleiben die Limits für die Antwortzeit gleich. \autocite{Nielson2010}


Die folgende Liste zeigt die Auswirkung der Antwortzeiten:
\begin{itemize}
\item 0.1 Sekunden gibt das Gefühl einer sofortigen Antwort. Das Ergebnis fühlt sich an, als wäre es vom Benutzer verursacht worden, nicht vom Computer. Dieses Level der Reaktionsfähigkeit wird von den Benutzern oder Benutzerinnen als direkte Manipulation empfunden.
\item 1 Sekunde hält den Gedankenfluss des Benutzers nahtlos. Benutzer können eine Verzögerung wahrnehmen und somit wissen sie, dass der Computer das Ergebnis erzeugt. Sie fühlen sich immer noch in der Kontrolle über das Gesamtergebnis und haben nicht das Gefühl auf den Computer zu warten. Dieser Grad an Reaktionsfähigkeit ist für eine gute Navigation erforderlich.
\item 10 Sekunden hält die Aufmerksamkeit des Benutzers oder der Benutzerin. In dem Bereich von 1-10 Sekunden fühlen sich die Benutzer und Benutzerinnen dem Computer ausgeliefert und wünschen sich eine shcnellere Reaktion. Nach 10 Sekunden fangen sie an über andere Dinge nachzudenken, was es schwieriger macht, ihre Gehirne wieder in die Spur zu bringen, wenn der Computer reagiert.
\end{itemize}

Jedes eingesparte Bit verringert die Zeit bis der Nutzer oder die Nutzerin eine Antwort erhält und hat somit eine positive Auswirkung auf die Benutzerzufriedenheit. Im Bereich der JavaScript Webentwicklung wird die Verrrigerung der Datenmenge vorallem durch die Minification des Programmcode erreicht. Der \textit{Static Bundler} Webpack bietet, seit der Veröffentlichung von Version 2 die Möglichkeit, mit Hilfe von \textit{Tree Shaking} nicht benutzten Code zu bereinigen und die Datenmenge intensiver zu verkleinern. \autocite{WebpackTreeShaking}


\section{Static Module Bundler}
\textit{Static Module Bundler} wie Webpack und RollupJS ermittelen alle für die Anwendung benötigten Module und bündeln diese anschließend in einer oder mehreren Dateien. Dafür wird ausgehend vom konfigurierten Einstiegspunkten ein Baum aus Abhängigkeiten erzeugt. Neben dem eigenen Programmcode beinhaltet dieser auch Npm Packete und statische Assets wie Bilder oder CSS Dateien. Die Abhängigkeiten werden aufgelöst, um daraus je nach Konfiguration eine oder mehrere \textit{Bundle} Dateien zu erzeugen. Je nach Anwendungsfall kann es von Vorteil sein den Programmcode als eine größere Datei oder in mehreren Teilen an den Browser auszuliefern, um ein möglichst schnelles Laden der Website zu gewährleisten.
\autocite{RollupJSDocs,WebpackConcepts}

\textit{Bundler} wie Webpack umhüllen jedes Code Modul mit Funktionen. Damit wird eine browserfreundliche Implementierung und das Laden der Assets je nach Bedarf gewährleistet \autocite{RichHarris}. Zu beachten ist der Unterschied zwischen Laden und Bündlen von Modulen. Werkzeuge wie SystemJS werden verwendet, um Module zur Laufzeit im Browser zu laden und zu übertragen. Im Gegensatz dazu werden bei Webpack Module durch sogenannte \textit{Loader} \textit{transpiliert} und gebündelt bevor sie den Browser erreichen. \autocite{WebpackComparison}

Dabei hat jede Methode ihre Vorteile und Nachteile. Das Laden und Übertragen von Modulen zur Laufzeit kann viel Aufwand für größere Sites und Anwendungen mit vielen Modulen verursachen. Aus diesem Grund ist SystemJS sinnvoll für kleinere Projekte, bei denen weniger Module benötigt werden. \autocite{WebpackComparison}

\section{Modules in JavaScript}
\label{section:modules_in_javaScript}
In traditionellen JavaScript Webprojekten werden alle Abhängigkeiten als Liste aus \lstinline{<script>} tags definiert. Es ist die Aufgabe des Entwicklers oder der Entwicklerin sicherzustellen, dass diese in der richtigen Reihenfolge zur Verfügung gestellt werden. Je komplexer die Abhängigkeiten zwischen dem  Programmcode, Frameworks und Libraries werden, desto schwieriger wird die Wartung und die richtige Platzierung neuer Einträge in der richtigen Reihenfolge. Es wurde bereits mit verschiedenen Modul Spezifikationen versucht diese Schwierigkeiten für Entwickler und Entwicklerinnen zu vereinfachen. \autocite{SebastianPeyrott}

\subsection{CommonJS}
Das Ziel von CommonJS ist eine Modul Spezifikation zur Erleichterung der Entwicklung von Serverseitigen JavaScript Anwendungen. NodeJS Entwickler  und Entwicklerinnen verfolgten anfangs diesen Ansatz, entschieden sich im späteren Verlauf jedoch dagegen. Dennoch wurde die Implementierung stark von der CommonJS Spezifikation beeinflusst. \autocite{SebastianPeyrott}

\begin{lstlisting}[
    label=listing:commonjs,
	caption=CommonJS Module,
	language=JavaScript
]
// In circle.js
const PI = Math.PI;

exports.area = (r) => PI * r * r;

exports.circumference = (r) => 2 * PI * r;

// In some file
const circle = require('./circle.js');
console.log( `The area of a circle of radius 4 is ${circle.area(4)}`);
\end{lstlisting}

In Listing \ref{listing:commonjs} erkennt man ein ComonJS JavaScript Modul und dessen Verwendung. Sowohl bei CommonJS als auch bei der NodeJS Implementierung gibt es zwei Elemente um mit dem Modul System zu interagieren: \lstinline{require} und \lstinline{exports}. \lstinline{require} wird benötigt um ein anderes Modul in den aktuellen Scope zu importieren. Dabei wird als Parameter die Modul-id angegeben. Diese ist entweder der Name des Moduls innerhalb des \lstinline{node_modules} Ordner oder der gesamte Pfad. \lstinline{exports} dient zur Definition einer Modul Schnittstelle. Jede \textit{Property} des \lstinline{exports} Objekts wird als öffentliches Element exportiert. Der Unterschied zwischen NodeJS und CommonJS liegt vorallem im \lstinline{module.exports} Objekt. Dies erfüllt dieselbe Aufgabe wie bei CommonJS das \lstinline{exports} Objekt. Abschließend bleibt zu erwähnen, dass die Module synchron geladen werden, das heißt in dem Moment und in der Reihenfolge in der sie mit \lstinline{require} angegeben wurden.\autocite{SebastianPeyrott}

\subsection{Asynchronous Model Definition (AMD)}

Das Entwickler Team von AMD spaltete sich wärend der Entwicklung von CommonJS ab. Der Hauptunterschied zwischen diese beiden Systemen liegt in dem asynchronen Laden von Ressourcen. \autocite{SebastianPeyrott}

\begin{lstlisting}[
    label=listing:amd,
	caption=Asynchronous Model Definition,
	language=JavaScript
]
//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
});

// Or:
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');

    return function () {};
});
\end{lstlisting}

Listing \ref{listing:amd} zeigt ein Beispiel für die Definition eines AMD Moduls. Das asynchrone Laden wird durch einen Funktionsaufruf nach dem Anfordern der Abhängigkeiten ermöglicht. Libraries, die nicht voneinander abhängig sind, können somit zur selben Zeit geladen werden. Dies ist besonders wichtig für die Frontend Entwicklung, da dort die Startzeit einer Anwendung essenziell für ein gutes Benutzererlebnis ist. \autocite{SebastianPeyrott}

\subsection{ECMAScript 6}
Ziel der ECMAScript 6 Modules Spezifikation war es, ein Format zu kreieren, welches sowohl AMD, als auch CommonJS Benutzer und Benutzerinnen zufriedenstellt. Die Spezifikation besitzt eine kompaktere Syntax als CommonJS und ähnlich zu AMD wird asynchrones Nachladen direkt unterstützt. Neben diesen Vorteilen wurde auch die Möglichkeit der statischen Code Analyse für Optimierungen geschaffen. 

ES6 bietet 2 Arten von Exporten: \textit{Named Exports} (mehrere Exporte pro Modul) und \textit{Default Exports} (einem Export pro Modul). \autocite{Rauschmayer2014}

\subsubsection{Named Exports}
\label{subsubsection:named_exports}

Mit Hilfe des Präfixes \lstinline{export} ist es möglich mehrere Elemente aus einem Modul zu exportieren. Dies gilt sowohl für Variablen als auch für Funktionen und Klassen. Sie werden anhand ihres Namens unterschieden und werden deshalb auch als \textit{Named Exports} bezeichnet. \autocite{Rauschmayer2014}

\begin{lstlisting}[
    label=listing:named_exports,
	caption=Named Exports,
	language=JavaScript
]
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
\end{lstlisting}

Neben dem gezeigt Weg in Listing \ref{listing:named_exports}, gibt es noch weitere Möglichkeiten um \textit{Named Exports} zu erzeugen. Eine Liste der verschiedenen Schreibweisen von ES6 Modul Importe\footnote{https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/import - besucht am 18.07.2018} und Exporte\footnote{https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/export - besucht am 18.07.2018} kann auf der MDN Web Docs Website gefunden werden.

\subsubsection{Default Exports}
\label{subsubsection:default_exports}

Es gibt den Fall, dass ein Modul nur ein Objekt exportiert. In der Frontendentwicklung tritt dies häufig auf, wenn nur eine Klasse oder ein Konstruktor implementiert wird. Dabei wird der \textit{Default Export} verwendet. Er ist das zentrale Export Element eines ECMAScript 6 Moduls und daher leichter als \textit{Named Exports} zu importieren. \autocite{Rauschmayer2014}

\begin{lstlisting}[
    label=listing:default_exports,
	caption=Default Exports,
	language=JavaScript
]
//------ myFunc.js ------
export default function () { ... };

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();

//------ MyClass.js ------
export default class { ... };

//------ main2.js ------
import MyClass from 'MyClass';
let inst = new MyClass();
\end{lstlisting}

Wie Listing \ref{listing:default_exports} veranschaulicht, besitzt der \textit{Default Export} keinen Namen. Beim Importieren wird daher meist der Modul Name für die Identifizierung verwendet.

 \begin{lstlisting}[
    label=listing:default_exports2,
    caption=Import Deklaration,
	language=JavaScript
]
import { default as foo } from 'lib';
import foo from 'lib';
\end{lstlisting}

\begin{lstlisting}[
    label=listing:default_exports3,
    caption=Export Deklaration,
	language=JavaScript
]
//------ module1.js ------
export default 123;

//------ module2.js ------
const D = 123;
export { D as default };
\end{lstlisting}

In Wirklichkeit ist der \textit{Default Export} auch ein \textit{Named Export} mit dem speziellen Namen \lstinline{default}. Somit sind die Import  und Export Deklarationen in Listing \ref{listing:default_exports2} und Listing \ref{listing:default_exports3} gleichbedeutend. \autocite{Rauschmayer2014}

\subsubsection{Static Module Structure}
Bei anderen Module Systemen wie CommonJS muss man den Programmcode ausführen, um herauszufinden, welche Importe und Exporte verwendet werden. Die Spezifikation von ES6 zwingen den Entwickler oder die Entwicklerin zu einer statischen Modul Struktur. In diesem Kapitel wird erläutert, was dies bedeutet und welche Vorteile dadurch entstehen.
\autocite{Rauschmayer2014}

Eine statische Modul Struktur ermöglicht durch Kompilieren des Codes, die darin befindlichen Importe und Exporte zu ermitteln. Es ist nicht nötig den Sourcecode auszuführen. In denm folgenden Listing \ref{listing:commonjs_nonstatic} wird gezeigt warum dies bei CommonJS nicht möglich ist. \autocite{Rauschmayer2014}

\begin{lstlisting}[
    label=listing:commonjs_nonstatic,
    caption=Flexible Struktur bei CommonJS,
	language=JavaScript
]
var mylib;
if (Math.random()) {
    mylib = require('foo');
} else {
    mylib = require('bar');
}

if (Math.random()) {
    exports.baz = ...;
}
\end{lstlisting}

Bei der CommonJS Deklaration aus Listing \ref{listing:commonjs_nonstatic} wird erst bei der Ausführung des Codes entschieden welcher Import beziehungsweise Export verwendet wird. Es6 Module besitzen nicht diese Flexibilität. Sie zwingen den Entwickler oder die Entwicklerin dazu, eine flache und statische Modul Struktur zu verwenden. Neben dem Verlust der Flexibilität bringt dies jedoch einige Vorteile mit sich. \autocite{Rauschmayer2014}

\subsubsection{Vorteile}

\textbf{1. Schneller Lookup}

CommonJS liefert beim Anfordern von abhängigen Modulen ein Objekt zurück. Beim Aufruf von zum Beispiel \lstinline{lib.someFunc();} muss ein langsamer \textit{Property Lookup} durchgeführt werden.

Im Gegensatz dazu sind die Inhalte bei dem Import eines ES6 Moduls bekannt. Der Zugriff auf die \textit{Properties} kann daher optimiert werden. \autocite{Rauschmayer2014}

\bigskip

\textbf{2. Variablen Überprüfung}

Dank der statischen Modul Struktur sind die verfügbaren Variablen innerhalb eines Moduls immer bekannt. Dazu zählen:
\begin{itemize}
\item Globale Variablen
\item Modul Importe
\item Modul Variablen
\end{itemize}
Dies bietet eine große Hilfe für Entwickler und Entwicklerinnen. Durch eine statische Überprüfung mit einem \textit{Linter} werden frühzeitige Tippfehler oder auch nicht verfügbare Variablen erkannt.\autocite{Rauschmayer2014}

\bigskip

\textbf{3. Macro Support}

Wenn eine JavaScript Engine Macros unterstützt, können Entwickler und Entwicklerinnen neue Syntaxen der Sprache hinzufügen.

\bigskip

\textbf{4. Type Support}

Eine statische Typprüfung ist nur möglich, wenn die Typdefinitionen statisch gefunden werden. In weitere Folge können Typen aus Modulen importiert werden, wenn diese eine statische Struktur besitzen.

\bigskip

\textbf{5. Unterstützung anderer Sprachen}

Um das Kompilieren von Sprachen mit Macros und statischen Typen zu JavaScript zu ermöglichen, sollten die Module aus den zwei zuvor genannten Gründen eine statische Struktur aufweisen.

\subsubsection{Schreibgeschützte Imports}
\label{subsubsection:importes}

Importe in CommonJS Modulen sind Kopien der exportierten Werte. Module Importe in ECMAScript 6 hingegen, sind schreibgeschützte Views auf die exportierten Entitäten. Dies bedeutet, dass Variablen die innerhalb eines Modules deklariert wurden, während der gesamten Programmlaufzeit bestehen bleiben. \autocite{Rauschmayer2018}


\begin{lstlisting}[
    label=listing:views,
    caption=Importe sind Views auf exportierte Entitäten,
	language=JavaScript
]
//------ lib.js ------
export let counter = 3;
export function incCounter() {
    counter++;
}

//------ main1.js ------
import { counter, incCounter } from './lib';

// The imported value `counter` is live
console.log(counter); // 3
incCounter();
console.log(counter); // 4

// The imported value can't be changed.
counter++; // TypeError
\end{lstlisting}

In Listing \ref{listing:views} ist die importierte Variable \lstinline{counter} schreibgeschützt. Sie kann jedoch durch den Aufruf der Funktion  \lstinline{incCounter} verändert werden.

In anderen Worten jeder Import ist eine Live-Verbindung zu den exportierten Daten. \textcite{Rauschmayer2018} zeigt die Unterschiede zwischen verschiedenen Importen in ES6:
\begin{itemize}
\item Unqualified imports wie zum Beispiel \lstinline{import x from 'foo'} verhalten sich wie mit \lstinline{const} deklarierte Variablen.
\item Wird ein gesamtes Module Objekt importiert \lstinline{import * as foo from 'foo'}, so verhält es sich wie ein mit \lstinline{Object.freeze} geschütztes Objekt.
\end{itemize}

Gemäß \textcite{ECMAScript} erzeugt die Methode \lstinline{CreateImportBinding(N, M, N2)} eine unveränderbare indirekte Bindung zu den Exporten eines anderen Moduls. Dabei wird überprüft, ob bereits ein Binding mit dem Namen \textbf{N} existiert. \textbf{M} ist die Bezeichnung des Moduls und \textbf{N2} ist der Name des von \textbf{M} exportierten Objekts.
Im Weiteren ist zu beachten, dass es nicht möglich ist die Werte von Importen zu ändern, es können jedoch die Objekte geändert werden, auf welche verwiesen wird. \autocite{Rauschmayer2018}

\begin{lstlisting}[
    label=listing:readonly_imports,
    caption=Importe sind schreibgeschützt,
	language=JavaScript
]
//------ lib.js ------
export let obj = {};

//------ main.js ------
import { obj } from './lib';

obj.prop = 123; // OK
obj = {}; // TypeError
\end{lstlisting}

Listing \ref{listing:readonly_imports} zeigt, dass importierte Objekt wie \lstinline{obj} nicht überschrieben werden können. Es ist jedoch möglich \textit{Properties} hinzuzufügen oder zu verändern.

Exporte in ES6 werden über den Export Eintrag verwaltet. Bis auf reexportierte Module besitzten alle Einträgen die folgenden zwei Namen: 

\begin{itemize}
\item Local Name: Ist der Name unter dem der Export im Module gespeichert ist.
\item Export Name: Importierende Module verwenden diesen Namen, um Zugang zu dem Export zu erhalten. Nachdem Importieren einer Entität, wird diese stets mittels des Pointers erreicht. Der Pointer besteht dabei aus den zwei Teilen Modul und Local Name und referenziert auf ein Binding innerhalb des Moduls.
\end{itemize}
\autocite{Rauschmayer2018}

Die nachfolgende angepasste Tabelle \ref{tbl:local_export_names} aus \textcite{ECMAScript} gibt einen Überblick über die Local und Export Namen verschiedener Export Varianten:

\begin{table}[H]
\centering
\caption{Local und Export Namen verschiedene Export Varianten}
\label{tbl:local_export_names}
\begin{tabular}{|l|l|l|}
\hline
Export Statement Form            & Export Name & Local Name \\ \hline
export var v;                    & v           & v          \\ \hline
export default function f()\{\}; & default     & f          \\ \hline
export default function()\{\};   & default     & *default*  \\ \hline
export default 42;               & default     & *default*  \\ \hline
export \{x\};                    & x           & x          \\ \hline
export \{v as x\};               & x           & v          \\ \hline
export \{x\} from "mod";         & x           & null       \\ \hline
export \{v as x\} from "mod";    & x           & null       \\ \hline
export * from "mod";             & null        & null       \\ \hline
\end{tabular}
\end{table}

\section{Tree Shaking}

\textit{Tree Shaking} bedeutet im Javascript Umfeld Dead-Code Elimination. Der Begriff und das dahinterliegende Konzept wurde durch den \textit{Static Bundler} RollupJS populär. Das Konzept des \textit{Tree Shaking} beruht auf der statischen Struktur von ES6 Modulen. Diese werden im Zusammenhang mit \textit{Bundlern} wie Webpack oder RollupJS in der Literatur auch als \textit{Pure Modules} oder \textit{Modules} oder \textit{Harmony Modules} bezeichnet. \autocite{WebpackTreeShaking}

Wie bereits in Kapitel \ref{section:modules_in_javaScript} gezeigt wurde ermöglicht die ES6 Spezifikation, sowohl die statische Analyse von Modulen als auch die Verwendung einer Teilmenge der zur Verfügung gestellten Exporte.
Für das nachfolgende Listing \ref{listing:treeshacking_helpers} wurde Webpack verwendet.

\begin{lstlisting}[
    label=listing:treeshacking_helpers,
	caption=helpers.js,
	language=JavaScript
]
export function hello() {
  return 'hello';
}
export function world() {
  return 'world';
}

export default {
  hello,
  world
}
\end{lstlisting}

\begin{lstlisting}[
    label=listing:treeshacking_index,
	caption=index.js,
	language=JavaScript
]
import {hello} from './helpers';

let elem = document.getElementById('output');
elem.innerHTML = `Output: ${hello()}`;
\end{lstlisting}

Listing \ref{listing:treeshacking_index} zeigt die Verwendung des zuvor Implementierten \lstinline{helpers.js} Moduls. Dabei ist zu beachten, dass lediglich die Methode \lstinline{hello} importiert und verwendet wird. \lstinline{world} gilt somit als Dead Code oder \textit{Unused Export }und wird in der gebündelten Anwendung nicht benötigt.

\begin{lstlisting}[
    label=listing:treeshacking_bundle,
	caption=bundle.js,
	language=JavaScript,
    firstnumber=79
]
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = hello;
/* unused harmony export world */
function hello() {
  return 'hello';
}
function world() {
  return 'world';
}

/* unused harmony default export */ var _unused_webpack_default_export = ({
  hello: hello,
  world: world
});
\end{lstlisting}

Um die unnötignen Codezeilen zu entfernen werden diese zuerst von Webpack markiert. In Listing \ref{listing:treeshacking_bundle} wurde sowohl der \textit{Default Export} als auch die \lstinline{world} Funktion mit \lstinline{unused harmony} markiert.

Webpack entfernt den unerwünschten Code nicht, erst der darauf folgendn Minifier erkennt die \lstinline{unused harmony} Annotationen und entfernt diese Segmente.

Die daraus resultierende \textit{Bundle} Datei beinhaltet eine stark verkleinerte \lstinline{hello} Funktion und die nicht benötigte Methode \lstinline{world} wurde aus der Datei entfernt. Auch wenn in diesem Beispiel der Gewinn nicht groß ist, kann \textit{Tree Shaking} dazu beitragen die \textit{Bundle} Datei in größeren Projekten signifikant zu verkleinern.
\autocite{WebpackTreeShaking}

\subsection{Webpack}

Um \textit{Tree Shaking} mit Webpack zu ermöglichen sind einige Konfigurationen nötig. 
Zuvor ist es wichtig einen genaueren Blick darauf zu werfen wie Webpack mit ES6 Modulen arbeitet.

Eine große Schwierigkeit bei der Verwendung von ES6 ist die Browser Inkompatibilität. Erstens dauert es eine gewisse Zeit bis die neuen Spezifikationen in den Browsern von den Herstellern implementiert werden können \autocite{CanIUseES6}. Zweitens benutzt ein beachtlicher Teil der Clients nicht die aktuellste verfügbare Version \autocite{CanIUseUsageTable}.

Um das Problem mit der Inkompatibilität zu umgehen werden JavaScript Compiler wie Babel verwendet. Diese verwandeln Es6 in einen für die meisten Browser kompatiblen JavaScript Code. Somit können Entwickler und Entwicklerinnen bereits die neusten Funktionen verwenden, ohne dass diese von dem Großteil der Browser unterstützt werden muss.\autocite{Babel}

Per Default wird von Babel jedes JavaScript Modul in CommonJS konvertiert. Durch die dynamische Implementierung von CommonJS Modulen können diese jedoch nicht statisch analysiert werden. Um ein erfolgreiches \textit{Tree Shaking} zu ermöglichen, ist es daher entscheidend, dies zu ändern.\autocite{Babel}

\begin{lstlisting}[
    label=listing:treeshacking_config,
	caption=webpack.config.js,
	language=JavaScript,
]
{
  entry: './index.js',
  output: {
    filename: 'dist/es6-modules/bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        query: {
          presets: [
            ['es2015', { modules: false }]
          ]
        }
      }
    ]
  }
}
});
\end{lstlisting}

Listing \ref{listing:treeshacking_config} zeigt eine typische \textit{Tree Shaking} Konfiguration von Babel und Webpack. Besonders wichtig ist die \lstinline{modules: false} Option von Babel. Mit dieser kann man die automatischen Modul Transformationen verändern. Neben dem \lstinline{false} Wert, der diese komplett deaktiviert, ist es ebenfalls möglich andere Optionen anzugeben (\lstinline{"amd" | "umd" | "systemjs" | "commonjs"}). \autocite{Babel}

\subsection{RollupJS}
Neben Webpack wurde das \textit{Tree Shaking} Konzept vor allem durch den \textit{Module Bundler} RollupJS bekannt \autocite{WebpackTreeShaking}. Dieser wird vor allem empfohlen beim Entwickeln von Libaries. Webpack wiederum bietet eine bessere Unterstützung für Assets wie Bilder oder CSS und gilt daher als besseres geeignet für die Erstellung von Apps. \autocite{RichHarris}

Der Unterschied zwischen den \textit{Bundlern} liegt in der Art und weise wie die einzelnen Module in der \textit{Bundle} Datei verpackt sind. Webpack hüllt jedes Modul in eine Funktion mit einer browser-freundlichen Implementierung von \lstinline{require} \autocite{RichHarris}. Features wie On-demand Loading werden dadurch erst möglich. \textcite{NolanLawson} konnte jedoch zeigen das dies im weiteren auch dazu führt, dass je mehr Module verwendet werden auch der damit einhergehende Overhead wächst.

RollupJS verwendet im Gegensatz die Möglichkeiten von ES6. Der gesamte Code landet an einem Platz und wird in einem Durchgang verarbeitet. Damit wird der Code schlanker und kann schneller starten. \autocite{RichHarris}

\subsection{Side Effects}
\label{subsection:side_effects}
In dieser Arbeit wird \textit{Tree Shaking} aus der Perspektive zweier Entwicklergruppen betrachtet. 

Zum einen jene Entwickler und Entwicklerinnen welche viel projektinternen JavaScript Code in ihren Web Projekten verwenden. \textcite{Nielson1997} zeigt den Zusammenhang zwischen der Ladezeit einer Seite und dem Benutzererlebnis. Das Ziel ist es folglich, eine oder mehrere möglichst kleiner \textit{Bundle} Dateien an den Client auszuliefern, für schnelle Seitenaufrufe und eine bessere \textit{User Experience}.

Die zweite Gruppe ist jene der Javascript Libary und Framework Entwickler. Ihr Sourcecode wird von vielen Projekten in verschiedener Art und Weise verwendet. In vielen Fällen wird in den Javascript Projekten nur ein kleiner Teil der importierten Libaries verwendet. Wenn diese \textit{Tree Shaking} unterstützt, können jedoch \textit{Bundler} wie Webpack, den nicht benötigten Code beim kompilieren der \textit{Bundle} Dateien entfernen.

In diesem Kapitel werden meherere Hindernisse für die beiden Benutzergruppen im Bezug auf Side Effects im Code veranschaulicht und in weitere Folge Maßnahmen zu Vermeidung dieser ermittelt. 

Umfangreiche und weitverbreitete JavaScript Libaries wie zum Beispiel Lodash\footnote{https://lodash.com/ - besucht am 26.05.2018} und jQuery\footnote{https://jquery.com/ - besucht am 26.05.2018} bieten eine große Anzahl an nützlichen Tools. Sie werden oft als NPM Modul installiert und anschließend in den Projektdateien als Import eingebunden. Zu meist werden nur Teile von den zu Verfügung gestellten Funktionalitäten auch wirklich verwendet. Das kann dazuführen das ein erheblich Teil der von Webpack erzeugten \textit{Bundle} Dateien aus nicht benötigten Code besteht. Plugins wie der \textit{Webpack Visualizer}\footnote{https://chrisbateman.github.io/webpack-visualizer/ - besucht am 12.07.2018} bieten eine einfache Möglichkeit, um festzustellen, welche Module in der von Webpack generierten \textit{Bundle} Datei am meisten Speicherplatz einnehmen.

Jedoch bietet unter anderem Webpack eine Möglichkeit für Library Entwickler und Entwicklerinnen ES6 Module so zu implementieren, dass der nicht benötigte Library Sourcecode beim Builden entfernt wird.
Durch die Verwendung von \lstinline{sideEffects: false} in der package.json Datei innerhalb der Library, wird Webpack mitgeteilt das \textit{Tree Shaking} nicht nur auf den üblichen Projektcode anzuwenden, sondern ebenfalls auf den Code der sich im Libary Ordner \lstinline{node_modules} befindet.

Dabei werden Importdeklarationen wie \lstinline|import {a, b} from "big-module-with-flag"| von Webpack erkannt und beim Bau der Applikation zu \lstinline|import a from "big-module-with-flag/a" import b from "big-module-with-flag/b"| umgeschrieben. Somit werden in der \textit{Bundle} Datei auch nur die zwei von dem Entwickler oder der Entwicklerin verwendeten Methoden importiert und der restliche Libary Code entfernt \autocite{WebpackTreeShaking}. Zur Veranschaulichung der Umwandlung von Importen existiert ein von Webpack zur Verfügung gestelltes Beispiel\footnote{https://github.com/webpack/webpack/tree/master/examples/side-effects - besucht am 26.05.2018}. 

Wenn mit Hilfe von \lstinline{sideEffects: false} ein Modul als \textit{pure} bezeichnet wird, werden alle nicht verwendeten Methoden, Klassen oder Objekte aus dem Code entfernt. Dies kann jedoch zur Entstehung von \textit{Side Effects} führen und somit die Funktionsweise stören. Ein \textit{Side Effect} ist als Code definiert, der beim Import ein anderes Verhalten ausführt als einen oder mehrere Exporte freizugeben. Ein Beispiel hierfür sind \textit{Polyfills}, die den globalen Geltungsbereich beeinflussen und normalerweise keinen Export bereitstellen. Dies wird im Weiteren in Listing \ref{listing:lib.js} und Listing \ref{listing:app.js} näher erläutert.

\begin{lstlisting}[
    label=listing:lib.js,
	caption=Libary mit Side Effects,
	language=JavaScript,
]
	import a from 'a'
    import b from 'b'
    
    console.log("das ist ein side effect")
    
    export {
    		a,
    		b
    }
\end{lstlisting}

\begin{lstlisting}[
    label=listing:app.js,
	caption=Verwendung der Libary,
	language=JavaScript,
]
	import { a } from 'lib'
    
    console.log("a:", a)
\end{lstlisting}

Listing \ref{listing:lib.js} zeigt eine Beispiel für einen Libary \textit{Entry Point}. Dieser exportiert alle Funktionalitäten die zur Verfügung gestellt werden.

Beim \textit{Tree Shaking} werden alle Imports umgeschrieben. Dabei wird \lstinline|import { a } from 'lib'| in Listing \ref{listing:app.js} zu \lstinline{import a from 'lib/a'} und somit wird jeglicher Programm Code in lib.js nicht ausgeführt. Die \lstinline{console.log} Nachricht in Zeile 4 wird somit nie angezeigt. Dies führt vorallem dann zu Problemen, wenn sich \textit{Side Effects} auf Exporte in der Datei auswirken. 

\begin{lstlisting}[
    label=listing:lib.js_with_sideeffect,
	caption=Side Effect mit Auswirkung auf Exporte,
	language=JavaScript,
]
	import { a } from 'lib'
    
	a.value = 'this value is dangerous'    
    
     export {
    		a
    }
\end{lstlisting}

In Listing \ref{listing:lib.js_with_sideeffect} wird wie in Listing \ref{listing:lib.js} \lstinline{a} exportiert. Davor wird in der Zeile 3 die \lstinline{importantValue} Eigenschaft hinzugefügt. Bei aktivem \textit{Tree Shaking} wird \lstinline{a} jedoch direkt mit \lstinline{import a from 'lib/a'} importiert. \lstinline{a.value} wird somit nie angelegt und kann nicht verwendet werden. Diese Unterschiede sind in spätere Folge für Benutzer und Benutzerinnen nur schwer nachzuvoll ziehen und Entwickler und Entwicklerinnen sollten bei der Erstellung einer Libary unbedingt diese vermeiden.\autocite{WebpackTreeShaking}

Mit \lstinline{sideEffects: false} betrachtet Webpack den gesamten Projektcode als \textit{Pure Module}. Sind für die ordnungsgemäße Ausführung jedoch einige Importe nötig, können Entwickler und Entwicklerinnen diese als String Array angeben. Dieses akzeptiert relative Pfade , absolute Pfade und \textit{Glob Pattern} zu den relevaten Dateien. Webpack verwendet Micromatch \footnote{https://github.com/micromatch/micromatch - besucht am 21.06.2018} zur Auflösung der Pfade.\autocite{WebpackTreeShaking}

CSS Dateien sind ein gutes Beispiel für Importe die in jedem Fall in dem gebündelten Programmcode enthalten sein müssen. Bei der Verwendung des \textit{CSS-Loader} und dem Importieren in einer Projektdatei, wird der CSS Code analysiert und die darin befindlichen Klassen stehen zur Verfügung. Sollten diese aber durch \textit{Tree Shaking} entfernt werden, fehlen die CSS Klassen und die dazugehörigen Styles in der Anwendung.
\autocite{WebpackTreeShaking}

\begin{lstlisting}[
    label=listing:sideeffectful.js,
	caption=sideeffectful.js mit CSS Side Effect,
	language=JavaScript,
]
	import './styles.css'

	console.log('sideeffectful file')

	export const sideeffect = 'sideeffect'
\end{lstlisting}

\begin{lstlisting}[
    label=listing:styles.css,
	caption=styles.css,
	language=HTML,
]
	.myClass {
    		background-color: blue;
	}
\end{lstlisting}

Listing \ref{listing:sideeffectful.js} zeigt ein JavaScript Modul, welches die CSS Datei \lstinline{styles.css} importiert. Mit der \lstinline{sideEffects: false} Webpack Konfiguration wird \lstinline{import './styles.css'} in Zeile 1 als \textit{Unused Export} erkannt und ist in der gebündelten Anwendung nicht mehr vorhanden. \lstinline{console.log('sideeffectful file')} und \lstinline{export const sideeffect = 'sideeffect'} werden jedoch noch ausgeführt.
Im Gegensatz dazu wird \lstinline{sideEffects: ["*.css"]} in der Konfigurationsdatei verwendet und der CSS Import mit in die \textit{Bundle} Datei übernommen. Auch wenn dies wegen dem Minify Schritt nicht sofort erkenntlich ist. Ist folgendes Code Segment darin zu finden \lstinline|function(e,n,o){(e.exports=o(2)(!1)).push([e.i,".myClass {\n    background-color: blue;\n}",""])}|.\autocite{WebpackTreeShaking}

\subsubsection{Untersuchung von JavaScript Libraries}
\label{subsubsection:untersuchung_von_js_libs}
Es existieren bereits Projekte auf NPM die \textit{Tree Shaking} verwenden. Durch eine Sourcecode Analyse sollen zusätzliche Erkenntnisse gewonnen werden, über die zum Einsatz kommenden Design Patterns und Möglichkeiten die Entwickler und Entwicklerinnen mit \textit{Linting} bei der Implementierung dieser zu unterstützen.
In weiterer Folge werden am Ende dieser Arbeit die ausgewählten Projekte mit dem ESLint \textit{Tree Shaking Plugin} auf Fehler und Warnungen getestet. Dabei sollten keine Fehler angezeigt werden, um die richtige Funktionsweise des Plugins sicherzustellen.

\textbf{Auswahlkriterien}

Die wichtigsten Kriterien für die zur Analyse ausgewählten Projekte ist zum einen die Verwendung eines \textit{Static Bundlers} und zum anderen eine bereits bestehende Implementierung von \textit{Tree Shaking}. Um dies festzustellen, wird zuerst geprüft ob eine package.json Datei im Repository existiert.

Anschließend wird in dieser nach \lstinline{sideEffects: false} gesucht. Wie bereits im Kapitel \ref{subsection:side_effects} veranschaulicht, dient die \lstinline{sideEffects} Einstellung dazu, dem \textit{Bundler} anzuzeigen, dass nur die verwendeten Exporte in dem gebuildeten Programmcode benötigt werden.
Die ausgewählten JavaScript Repositories sollten  für eine möglichst große Anzahl an Entwicklern und Entwicklerinnen von relevanter Bedeutung sein. Für die Auswahl werden daher jene NPM Module verwendet, welche am häufigsten in Webprojekten verwendet werden. Es existiert bereits eine generische Liste \footnote{https://www.npmjs.com/browse/depended - besucht am 06.06.2018} die diese Module beinhaltet.

Auf NPM befinden sich neben Bibliotheken welche ES6 verwenden, auch welche die für NodeJS entwicklert wurden. Libraries welche mit NodeJS Modulen implementiert wurden sind für diese Arbeit nicht geeignet \autocite{NodeJSModules}. Ein weiteres Kriterium für die Auswahl der zu untersuchenden Projekte ist daher die Verwendung von ES6 Modulen.
Anhand dieser Auswahlkriterien wurden folgende drei Projekte ermittelt, welche \textit{Tree Shaking} und ES6  implementieren:

\begin{itemize}
	\item{lodash\footnote{https://github.com/lodash/lodash/tree/es - besucht am 15.06.2018}}
	\item{vue\footnote{https://github.com/vuejs/vue - besucht am 15.06.2018}}
	\item{graphql\footnote{https://github.com/graphql/graphql-js - besucht am 15.06.2018}}
\end{itemize}

Anforderungen für \textit{Tree Shaking} werden mit einer Sourcecode Analyse ermittelt und die daraus gewonnen Erkenntnisse im nachfolgenden Kapitel \ref{subsubsection:best_practices} dokumentiert.

\textbf{Implementierung von \textit{Tree Shaking}}

In den ausgewählten Repositories wurde \textit{Tree Shaking} mit \lstinline{sideEffects: false} in der pakage.json Datei aktiviert. Somit werden bei der Verwendung \textit{Named Imports} wie zum Beispiel \lstinline|import {add} from 'lodash'|, diese aufgelöst zu \lstinline{import add from 'lodash/add'}. In weiterer Folge wird sämtlicher nicht genutzter Programmcode der Library entfernt und nur die verwendeten Module in die \textit{Bundle} Datei integriert.

Webpack startet mit der Erzeugung des \textit{Bundles} bei dem definierten \textit{Entry Point}. In den untersuchten Repositories dient diese Datei, um die gewünschten Funktionalitäten nach außen zu exportieren. Wie bereits im Kapitel \ref{subsection:side_effects} festgestellt wurde, können mögliche \textit{Side Effects} in dieser Datei entfernt werden. In allen drei Fällen werden daher lediglich \lstinline{import} und \lstinline{export} verwendet.

Da Programmcode außerhalb des benötigten Moduls nicht garantiert in der \textit{Bundle} Datei enthalten ist, wurde der gesamte Sourcecode in für sich eigenständige Module aufgeteilt. Dies bedeudet, dass Module wie zum Beispiel \lstinline{add.js} alle Resourcen, welche für die ordnungsgemäße Funktionalität benötigt werden, importieren müssen.

\subsubsection{Best Practices zur Vermeidung von Side Effects}
\label{subsubsection:best_practices}

Anhand der untersuchten Eigenschaften und Libraries wurden die folgenden Anforderungen in Bezug auf Vermeidung von \textit{Side Effects} ermittelt, diese werden bei der Implementierung berücksichtigt und am Ende diese Arbeit auf ihre Wirksamkeit überprüft.

\begin{itemize}
\item Besitzt ein Modul \textit{Named Exports} ist darauf zu achten, dass auf diese keine \textit{Side Effects} wirken.
\item Bei der Verwendung eines \textit{Default Exports} wird die gesamte Datei eingebunden. Jegliche \textit{Side Effects} innerhalb der Datei werden somit inkludiert.
\item Importe welche den Body eines Moduls ausführen werden von \textcite{Rauschmayer2018} als \textit{Empty Imports} bezeichnet, können beim bündlen entfernt werden und müssen deshalb als \textit{Side Effect} in der \lstinline{package.json} Datei vermerkt werden.
\item Der \textit{Entry Point} einer Library sollte für sich eigenständige Module importieren und diese als \textit{Named Exports} zur Verfügung stellen. Dieser sollte keine \textit{Side Effects} beinhalten.
\end{itemize}

\section{Linting}
Der Begriff \textit{Lint} wurde erstmals in den 1970er Jahren in Verbindung mit der Softwareentwicklung erwähnt. \textcite{Johnson1978} entwicklete es an den Bell Laboratories um die Schwächen der damaligen C Compiler auszugleichen und unentdeckte Fehler in bereits kompilierten Programmen zu finden.

Es existieren viele Wege um die Anzahl an Bugs innerhalb einer Anwendung zu minimieren. Neben dem Schreiben von Unit Tests bieten Code Reviews laut \textcite{Louridas2006} wohl die beste Möglichkeit Bugs und Code Smells aufzufinden und zu eliminieren. Es fordert jedoch einen großen Zeitaufwand mehrere Entwickler zusammenzubringen und die gesamte Codebasis einer Anwendung gemeinsam zu reviewen.

Die meisten Fehler fallen in die Kategorie Known Errors. Dies sind häufig auftretende sich wiederholende Fälle in denen die Entwickler und Entwicklerinnen immer wieder hineinstoplern. Mit \textit{Linting} möchte man die sich ständig wiederholenden Fehler oder auch Code Smells so früh wie möglich finden und ausbessern. \autocite{Louridas2006}

Im Gegensatz zu einem \textit{Compiler} muss beim \textit{Linting} der Code nicht ausgeführt werden. So genannte Static Checker durchlaufen den Programmcode auf der Suche nach bestimmten Mustern, dieser Prozess wird als Statische Code Analyse bezeichnet. \autocite{Louridas2006}

Es gibt verschiedene Wege, um eine statische Code Analyse durchzuführen. Wie zum Beispiel auf Anfrage eines Entwicklers oder einer Entwicklerin, kontinuierlich während der Erstellung einer Anwendung oder aber direkt bevor ein Entiwckler oder eine Entwicklerin Codeänderungen auf ein Repository comitten will. Je nach Projekt können somit Fehler entdeckt und behoben werden bevor diese in der Codebasis am Repository landen.\autocite{Johnson2013}

Es exisitiert bereits Literatur zur statischen Code Analyse. Dabei wurden nicht nur Aspekte wie Performance und Genauigkeit untersucht \autocite{Bessey2010}, sondern auch verschiedene Einsatzgebiete gezeigt \autocite{Bush2000}.

\textcite{Johnson2013} erforschten in ihrer Arbeit den Gebrauch und die Verbreitung von statische Analyse Tools. Ein Teil davon war die Ermittlung, was Entwickler und Entwicklerinnen bei dem Gebrauch dieser Werkzeuge als störend empfinden. Ergebnis davon war der nicht zu unterschätzende Anteil an false postives, das heißt die Anzahl an Warnungen, die keine wirklichen Fehler sind. Im Weiteren wurde auch noch die hohe Arbeitslast von Entwicklern und Entwicklerinnen genannt. Laut \textcite{Johnson2013} sollten zukünftige Tools, sowohl eine bessere Integration in den Arbeitsabläufen von Entwicklern und Entwicklerinnen bieten, als auch die Arbeit in einem Team besser unterstützen.

\textcite{Bush2000} implementierte ein statisches Analyse Tool zum Auffinden von dynamischen Fehlern in C und C++. Dazu zählen unter anderem die Verwendung von nicht intitialisierten Speicher oder falschen Operation auf Dateien (zum Beispiel das Schließen einer Datei die bereits geschlossen wurde). Für das aus der Arbeit entstandene Tool wurde die Bezeichnung \textit{PREFix} ausgewählt. Zur Analyse von Code wird der \textit{Abstract Syntax Tree} generiert und anschließend die Funktionsaufrufe mittels eines topolischen Algorithmus sortiert. Die Funktionen werden daraufhin simuliert und darin befindliche Defekte gemeldet. Als Teil dieser Arbeit wird ein Plugin erstellt, welches wie bei \textcite{Bush2000} den \textit{Abstract Syntax Tree} auf ähnliche Art und Weise untersucht. Jedoch soll dies für die Programmiersprache JavaScript erfolgen und sich lediglich auf fehlerhafte Muster bei der Verwendung von ES6 Imports und Exports fokussieren.

\subsection{ESLint}
2013 erschuf der Entwickler Nicholas C. Zakas ESLint ein erweiterbares \textit{Linting} Tool für JavaScript und JSX. Neben vielen vorhandenen \textit{Linting} Regeln bietet  ESLint eine Möglichkeit für Entwickler und Entwicklerinnen solche auch selbst zu implementieren. Durch Hinzufügen oder Entfernen von Regeln wird der \textit{Linting} Prozess je nach Projekt und Team konfiguriert. Dabei gelten für jede Regel die folgenden drei Grundsätze:
\begin{itemize}
  \item Jede Regel sollte eigenständig funktionieren
  \item Jede Regel bietet eine Möglichkeit zum An und Abschalten (nicht darf als zu wichtig zum deaktivieren gelten)
  \item Es kann zwischen Warnung und Fehler gewechselt werden
\end{itemize}
Um nicht jede Regel einzeln zu importieren gibt es ebenfalls die Möglichkeit mehrere Regeln als \textit{Bundle} auszuliefern. \autocite{ESLintAbout}

Ziel dieser Arbeit ist es, Anforderrungen für die Optimierung von ES6 Exports und Imports zu identifizieren. Des Weiteren werden Regeln für ESLint erstellt, welche schlechte Muster im Programmcode aufdecken und Lösungen dafür anzeigen. \autocite{ESLintAbout}

\subsection{Core Rules}
\label{subsubsection:core_rules}

ESLint wird bereits mit mehr als, 200 allgemein gültigen Regeln ausgeliefert. Diese werden als Core Regeln bezeichnet. Gemäß \autocite{ESLintNewRules}, muss eine eigene Regel die folgenden sechs Eigenschaften erfüllen, um diese der Core Liste hinzuzufügen:

\textbf{Allgemeine Anwendbarkeit:}
Core Regeln sollten relevant für eine große Anzahl an Entwicklern und Entwicklerinnen sein. Regeln für individuelle Präferenzen oder Edge Cases werden nicht akzeptiert.

\textbf{Generisch:}
Neue Regeln sollten möglichst generisch sein. Ein Benutzer oder eine Benutzerin darf keine Schwierigkeiten haben zu verstehen, wann eine Regel zu benutzen ist. Als Richtlinie gilt, dass eine Regel zu spezifisch ist, wenn man zur Beschreibung ihrer Funktion mehr als zwei ``und'' benötigt. (zum Beispiel: Wenn a und b und c und d, dann wird der Benutzer oder die Benutzerin gewarnt)

\textbf{Atomar:}
Regeln sollten vollkommen selbstständig funktionieren. Abhängikeiten zwischen zwei oder mehreren Regeln sind nicht erlaubt.

\textbf{Einzigartig:}
Überschneidung zwischen Regeln sind ebenfalls nicht erlaubt. Jede sollte eine eigene Warnung erzeugen. Somit wird der Benutzer nicht unnötig verwirrt.

\textbf{Unabhängig:}
Regeln dürfen nur auf der JavaScript Laufzeitumgebung basieren und müssen unabhängig von Libaries oder Frameworks sein. Core Regeln sollten stehts anwendbar sein und nicht davon abhängen, ob spezielle Libaries wie JQuery verwendet werden. Hingegen existieren bereits einige Regeln, die nur angewendet werden, wenn die Laufzeitumgebung NodeJS vorhanden ist.

\textbf{Ohne Konflikte:}
Keine Regel sollte sich mit anderen Regeln überschneiden. Zum Beispiel gibt es eine Regel, welche von einem Entwickler oder einer Entwicklerin verlangt, jedes Statement mit einem Semikolon zu beenden. Es ist nicht erlaubt eine neue Regel zu entwerfen, die Semikolons verbietet. Stattdessen existiert die Regel Semi, welche beides erlaubt und mit Hilfe der Konfiguration gesteuert werden kann.

Das in dieser Arbeit entstehende Plugin und die dazugehörigen Regeln soll Entwickler und Entwicklerinnen beim Umgang mit \textit{Tree Shaking} und in Zusammenhang mit \textit{Static Module Bundler} wie Webpack unterstützen. Die allgemeine Anwendbarkeit der Regeln ist somit nicht gegeben und diese können folglich auch nicht als Core Regeln eingereicht werden.


\subsection{Erzeugung  und Traversierung des Abstract Syntax Tree}
\label{subsubsection:erzeugen_des_abstract_syntax_tree}
Ein \textit{Abstract Syntax Tree (AST)} erfasst die wesentliche Struktur des Programmcodes, mit Verzicht auf unnötige syntaktische Details in der Form eines Baumes. Dabei werden die unterschiedlichen Konstrukte der Programmiersprache als \textit{Node Types} representiert. \autocite{Jones2003}

ESLint verwendet für die Erstellung des AST einen eigenen Parser Namens Espree\footnote{https://github.com/eslint/espree - besucht am 12.07.2018} \autocite{ESLintEspree}. Dieser wurde auf Basis des JavaScript Parsers Acorn\footnote{https://github.com/acornjs/acorn - besucht am 12.07.2018} gebaut. Die modulare Architektur von Acorn ermöglicht eine einfache Erweiterung von Kernfunktionalitäten. Der von Espree erzeugte AST und dessen \textit{Nodes} entspricht der von ESTree\footnote{https://github.com/estree/estree - besucht am 12.07.2018} spezifizierten Syntax.

Jede ESLint Regel implementiert eine \lstinline{create} Funktion. Diese retourniert ein Objekt mit Methoden. Diese werden von ESlint aufgerufen um \textit{Nodes} zu besuchen während der Traversierung durch den \textit{Abstract Syntax Tree}. Jede dieser \textit{Visitor Functions} wird mit einem \textit{Key} oder auch \textit{Selector} definiert. Sollte dieser einem \textit{Node Type} entsprechen, so wird die \textit{Visitor Function} auf die \textit{Node} aufgerufen. \autocite{ESLintRules}

\section{Erweiterte Analyse durch die Erstellung eines ESLint Plugins}
\subsection{Setup}
Um die Projektstruktur aufzusetzen wird die von \textcite{ESLintNewRules} empfohlene Vorgehensweise verwendet. Wichtige Voraussetzungen um ein ESLint Plugin zu erstellen sind NPM und NodeJS, diese müssen zuerst installiert werden. In dieser Arbeit wird NodeJS v8.0.0 und NPM 5.8.0 verwendet.

Des weiteren wird das Commandline Tool Yeoman benötigt. Die aktuellste Version ist 2.0.2, diese wird mit dem Befehl \lstinline{npm install -g yo} global installiert und steht somit in der Konsole an jedem Ort zur Verfügung. Zuletzt wird das NPM Modul eslint-generator installiert es dient dazu ein leeres Gerüst für den Plugin Code zu erstellen.

Nach der Installation wird mit dem Befehl \lstinline{yo eslint:plugin} der Generator gestartet. Folgende Daten wurden dabei angegeben:
\begin{itemize}
	\item \textbf{Name:} silltho
    \item \textbf{Plugin-Id:} threeshaking
    \item \textbf{Beschreibung:} Webpack Tree Shaking Support
    \item \textbf{Werden Benutzerdefinierte Regeln verwendet?:} Ja
    \item \textbf{Werden Processors verwendet?:} Nein
\end{itemize}

\begin{lstlisting}[
    label=listing:package.json,
	caption=generierte package.json Datei,
	language=JavaScript,
]
{
  "name": "eslint-plugin-treeshaking",
  "version": "0.0.0",
  "description": "Webpack Tree Shaking Support",
  "keywords": [
    "eslint",
    "eslintplugin",
    "eslint-plugin"
  ],
  "author": "silltho",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha tests --recursive"
  },
  "dependencies": {
    "requireindex": "~1.1.0"
  },
  "devDependencies": {
    "eslint": "~3.9.1",
    "mocha": "^3.1.2"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "license": "ISC"
}
\end{lstlisting}

Listing /ref{listing:package.json} zeigt die daraus resultierende package.json Datei.

In weiterer Folge wurden neben der \lstinline{README.md} Datei auch ein \lstinline{lib} und \lstinline{tests} Ordner im Projektverzeichnis erstellt. Der Ordner \lstinline{lib/rules} wird später den Programmcode für die neu erstellten Regeln beinhalten.

\subsection{Entwicklungsumgebung}
Für die Programmierung wird die integrierte Entwicklungsumgebung (IDE) WebStorm von JetBrains in der Version 2018.1.2 verwendet. Zum Zeitpunkt dieser Arbeit ist die aktuellste verfügbare ESLint Version 4.19.1. In weitere Folge wird Prettier\footnote{https://prettier.io/ - besucht am 04.07.2018} für die Code Formatierung genutzt. Anschließend wurde noch Husky\footnote{https://github.com/typicode/husky - besucht am 04.07.2018} verwendet, um \textit{Git Hooks} für Prettier und die Test Suite zu registrieren.


\subsection{Implementierung der Plugin Regeln}
Yeoman in Verbindung mit dem ESLint-Generator unterstützt Entwickler und Entwicklerinnen nicht nur beim Erzeugen der Projektdateien sondern ebenfalls bei dem Anlegen neuer Regeln innerhalb des Plugins. Die dafür nötigen Dateien werden mit dem Befehl \lstinline{yo eslint:rule} erzeugt. Die neu erstellten Regeln innerhalb des Plugins sollen die Aufmerksamkeit von Entwickler und Entwicklerinnen auf die Probleme aus Kapitel \ref{subsubsection:best_practices} richten und Wege aufzeigen um diese zu vermeiden. In diesem Kapitel wird dokumentiert, wie die Regeln erstellt wurden. 

Beim Aufruf des Generators mit \lstinline{yo eslint:rule} müssen mehrere Fragen beantwortet werden:

\begin{itemize}
	\item What is your name?
    \item Where will this rule be published?
    \item What is the rule ID?
    \item Type a short description of this rule
    \item Type a short example of the code that will fail
\end{itemize}

In dieser Arbeit wird als Name ``silltho'' verwendet. Als den Publishing Ort kann entweder ESLint Core oder ESLint Plugin gewählt werden. Wie bereits im Kapitel \ref{subsubsection:core_rules} beschrieben wurde, eignen sich die in dieser Arbeit erstellten Regeln nicht als Core Regeln, es wird somit bei allen Regeln die Option ESLint Plugin gewählt. 

Alle weiteren Fragen können je nach Regel unterschiedlich beantwortet werden. In weiterer Folge werden diese in den Tabellen \ref{tbl:empty_imports}, \ref{tbl:named_exports} und \ref{tbl:entry_point} bei der Implementierung jeder Regel dargestellt.

Vom Generator werden abschließend die folgenden Dateien im Projektverzeichnis erzeugt:
\begin{itemize}
	\item \textbf{docs/rules/(rule-id).md} - Dokumentation der Regel und der Konfiguration Möglichkeiten.
    \item \textbf{lib/rules/(rule-id).js} - Programmcode.
    \item \textbf{tests/lib/rules/(rule-id).js} - Tests um sicherzustellen das die Regel wie gewünscht funktioniert.
\end{itemize}

Die nachfolgenden Kapitel beschreiben die Implementierung der Regeln die benötigt werden um Code Smells beim \textit{Tree Shaking} für Entwickler und Entwicklerinnen anzuzeigen.

\subsubsection{Empty Imports}

\begin{table}[H]
\centering
\caption{Yeoman Generator: Empty Imports}
\label{tbl:empty_imports}
\begin{tabular}{|l|l|}
\hline
Rule-ID: & no-empty-imports \\ \hline
Beschreibung: & disallow Empty Imports \\ \hline
\end{tabular}
\end{table}

Gemäß den Erkenntnissen aus  Kapitel \ref{subsection:side_effects} müssen \textit{Empty Imports} wie zum Beispiel \lstinline{import 'module1'} als \textit{Side Effect} gekennzeichnet werden. Diese werden sonst beim Bündeln des Programmcodes als \textit{Unused Imports} erkannt und entfernt. Ziel dieser Regel ist es die Aufmerksamkeit von Entwicklern und Entwicklerinnen auf diese Art von Imports zu richten und sie daran zu erinnern, diese in der  \lstinline{package.json} Datei als \textit{Side Effect} zu vermerken.

Um diese Funktionsweise zu gewährleisten, wurde folgende Test Datei \lstinline{test/lib/rules/empty-imports.js} erstellt: 

\begin{lstlisting}[
    label=listing:empty_import_test,
	caption=Empty Imports Unit Tests,
	language=JavaScript,
]
var ruleTester = new RuleTester();
ruleTester.run("empty-imports", rule, {

    valid: [
      {
        options: [['empty-import']],
        code: `
          import 'empty-import'
          import lib1 from 'lib1'
          export const export1 = 'export1'
          export default 'default'
        `,
        errors: []
      },
      {
        options: [],
        code: `
          import name from "module-name";
          import * as name2 from "module-name";
          import { member } from "module-name";
          import { member as alias } from "module-name";
          import { member1 , member2 } from "module-name";
          import { member3 , member2 as alias2 } from "module-name";
          import defaultMember, { member4 } from "module-name";
          import defaultMember2, * as alias3 from "module-name";
          import defaultMember3 from "module-name";
        `,
        errors: []
      }
    ],

    invalid: [
        {
            code: `
                import 'empty-import'
                import lib1 from 'lib1'
                export const export1 = 'export1'
                export default 'default'
            `,
            errors: [{
                message: 'empty imports are removed by tree shaking. Make sure you add empty-import to package.json sideEffects option.',
                type: 'ImportDeclaration'
            }]
        }
    ]
});
\end{lstlisting}

Im ersten Schritt werden mit dem AstExplorer\footnote{https://astexplorer.net/ - besucht am 26.06.2018} die 
verschiedenen Import \textit{Nodes} analysiert. Der \textit{Node Type} für Importe in ES6 ist \lstinline{ImportDeclaration}. In weiterer Folge konnte festgestellt werden, dass \textit{Empty Import Nodes} keine \textit{Specifier} besitzen, somit ist \lstinline{importNode.specifiers.length === 0} true, falls es sich um einen \textit{Empty Import} handelt. Mit Hilfe dieser Erkenntnisse ist es bereits möglich \textit{Empty Imports} aufzuspüren und zu kennzeichnen.

\begin{lstlisting}[
    label=listing:empty_import_rule_1,
	caption=Code zum Aufspüren von Empty Imports,
	language=JavaScript,
]
        function isEmptyImport(importNode) {
            if(importNode.specifiers.length === 0) {
              reportEmptyImport(importNode)
            }
        }

        return {
          'ImportDeclaration': isEmptyImport
        };
\end{lstlisting}

Nach der Implementierung von Listing \ref{listing:empty_import_rule_1} werden zwei der drei Tests bereits erfolgreich durchgeführt.  Beim ersten validen Test wird jedoch der Fehler \lstinline{AssertionError [ERR_ASSERTION]: Should have no errors but had 1} angezeigt. \textit{Empty Imports} können in der \lstinline{package.json} Datei als \textit{Side Effects} vermerkt werden. Diese werden anschließend im Programmcode inkludiert und können verwendet werden. Die \textit{Empty Imports} Regel sollte dahingehend konfigurierbar sein.

Hierfür sollte man als Option ein Array von Pfaden und \textit{Glob Pattern} übergeben gleich zu der \textit{Side Effects} Einstellung von Webpack. \textcite{WebpackTreeShaking} zeigt, dass für die Auflösung der \lstinline{sideEffects} \textit{Property} die Bibliothek Micromatch \footnote{https://github.com/micromatch/micromatch - besucht am 26.06.2018} verwendet wird. Für die Auflösung der Array Daten innerhalb der Regel wird dieselbe Library verwendet, um die Unterschiede zwischen Webpack und der Regel Konfiguration möglichst gering zu halten.

Damit die \textit{Empty Imports} Regel ein Array von Strings als \textit{Property} akzeptiert, muss die Schema Konfiguration in \lstinline{lib/rules/empty-imports.js} wie folgt angepasst werden:

\begin{lstlisting}[
    label=listing:empty_import_rule_2,
	caption=Empty Import Option Schema,
	language=JavaScript,
]
      schema: [
        {
          type: 'array'
        }]
    }
\end{lstlisting}

Anschließend kann auf die Konfiguration mittels \lstinline{context.options[0]} zugegriffen werden.

\begin{lstlisting}[
    label=listing:empty_import_rule_3,
	caption=isKnownSideEffect Funktion,
	language=JavaScript,
]
        function isKnownSideEffect(emptyImportNode) {
          return mm.any(emptyImportNode.source.value, knownSideEffects, null)
        }
\end{lstlisting}

Listing \ref{listing:empty_import_rule_3} beinhaltet die Implementierung der \lstinline{isKnownSideEffect} Funktion. Diese vergleicht den Value eines Imports mit dem übergebenen Array. Micromatch bietet dafür die Methode \lstinline{any(str, patterns, options)} an. Diese vergleicht den übergebenen String mit dem Patternsarray und liefert true falls ein beliebiges Pattern in dem Array mit dem String übereinstimmt.

Zuletzt muss noch die \lstinline{isEmptyImport} Methode angepasst werden, um mit der neuen Funktion \lstinline{isKnownSideEffect} alle \textit{Empty Imports} zu überprüfen.

\begin{lstlisting}[
    label=listing:empty_import_rule_3,
	caption=isEmptyImport Funktion,
	language=JavaScript,
]
        function isEmptyImport(importNode) {
            if(importNode.specifiers.length === 0 && !isKnownSideEffect(importNode)) {
              reportEmptyImport(importNode)
            }
        }
\end{lstlisting}

Listing \ref{listing:empty_import_rule_3} veranschaulicht die Anpassungen an der \lstinline{isEmptyImport} Funktion. Beim erneuten Ausführen der Tests werden alle erfolgreich abgeschloßen. Die Regel ist somit erfolgreich Implementiert und wird im Kapitel \ref{subsection_testen_des_plugins} auf ihre Wirksamkeit geprüft.

\subsubsection{Named Exports Side Effects}

\begin{table}[H]
\centering
\caption{Yeoman Generator: Named Exports Side Effects}
\label{tbl:named_exports}
\begin{tabular}{|l|l|}
\hline
Rule-ID: & no-named-exports-sideeffects \\ \hline
Beschreibung: & disallow Side Effects onto Named Exports \\ \hline
\end{tabular}
\end{table}

Ein weiterer Code Smell aus Kapitel \ref{subsection:side_effects} ist der Gebrauch von \textit{Side Effects }auf \textit{Named Exports}.

\begin{lstlisting}[
    label=listing:counter.js,
	caption=counter.js,
	language=JavaScript,
]
let counter = 1

const incCounter = (newValue) => {
	counter++
}

export {
	incCounter,
	counter
}
\end{lstlisting}

\begin{lstlisting}[
    label=listing:named_exports_sideeffects_rule_1,
	caption=lib.js,
	language=JavaScript,
]
	import { counter, incCounter } from "counter";
	incCounter();
	export { counter }
\end{lstlisting}

\begin{lstlisting}[
    label=listing:named_exports_sideeffects_rule_2,
	caption=index.js,
	language=JavaScript,
]
	import { counter } from "lib";
	console.log(counter) // 1
\end{lstlisting}

Listing \ref{listing:counter.js}, \ref{listing:named_exports_sideeffects_rule_1} und \ref{listing:named_exports_sideeffects_rule_2} zeigen ein Beispiel für einen \textit{Side Effect}. Obwohl die Methode \lstinline{incCounter} in \lstinline{lib.js} aufgerufen wird, wird durch \textit{Tree Shaking} \lstinline|import { counter } from "lib"| zu \lstinline|import { counter } from "counter"|. Somit wird die Datei \lstinline{lib.js} nicht inkludiert und auch der \lstinline{incCounter} Aufruf geht in weiterer Folge verloren.

Für die Implementierung werden \textit{Imports} (\lstinline{import}), \textit{Named Exports} (\lstinline{export}) und \textit{Expressions} (\lstinline{incCounter} oder \lstinline{counter.test = '123'}) benötigt. Mit dem ASTexplorer wurden erneut die dazugehörigen \textit{Node Types} \lstinline{ImportDeclaration}, \lstinline{ExportNamedDeclaration} und \lstinline{ExpressionStatement} ermittelt.

Die folgende Testdatei soll die Funktionsfähigkeit der Regel sicherstellen. Insgesamt wurden 4 valide und 4 invalide Szenarien ausgearbeitet. Diese können im anschließenden Listing \ref{listing:named_exports_sideeffects_test} betrachtet werden.

\begin{lstlisting}[
    label=listing:named_exports_sideeffects_test,
	caption=Named Exports Side Effects Unit Tests,
	language=JavaScript,
]
var ruleTester = new RuleTester()
ruleTester.run('named-exports-sideeffects', rule, {
  valid: [
    {
      options: [],
      code: `
          import name from "module-name";
          import name2 from "module-name2";
          name2.sideeffect = 'sideeffect'
          export {
            name
          }
          export default name2
        `,
      errors: []
    },
    {
      options: [],
      code: `
          testFunction = () => {
            console.log('test')
          }
          export {
            testFunction
          }
        `,
      errors: []
    },
    {
      options: [],
      code: `
          import name from "module-name";
          import name2 from "module-name2";
          console.log('test123')
          export default name2
        `,
      errors: []
    },
    {
      options: [],
      code: `
          import name from "module-name";
          import name2 from "module-name2";
          const tmp = 'tmp'
          export {
            tmp as name,
            name as name2
          }
        `,
      errors: []
    }
  ],

  invalid: [
    {
      options: [],
      code: `
            import test2 from "module-name2";
            test2.sideeffect = 'sideeffect'
            export { test2 }
    `,
      errors: [
        {
          message:
            'Effects on reexported modules (test2) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: [],
      code: `
          import test2 from "module-name2";
          test2.init('initSomeThing')
          export { test2 }
        `,
      errors: [
        {
          message:
            'Effects on reexported modules (test2) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: [],
      code: `
          import { counter as temp1, incCounter as temp2 } from "module-name2";
          temp2();
          export { temp1 as tmp }
        `,
      errors: [
        {
          message:
            'Effects on reexported modules (temp1) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: [],
      code: `
          import { counter, incCounter } from "module-name2";
          incCounter();
          export { counter }
        `,
      errors: [
        {
          message:
            'Effects on reexported modules (counter) could be prune by TreeShaking.',
          type: 'ExpressionStatement'
        }
      ]
    }
  ]
})

\end{lstlisting}

Die invaliden Testfälle aus Listing \ref{listing:named_exports_sideeffects_test} können in zwei Kategorien eingeteilt werden. Die erste Kategorie bilden direkte \textit{Side Effects} wie zum Beispiel \lstinline{test2.init('initSomeThing')}. Dieser wirkt direkt auf das zuvor importierte \lstinline{test2} Modul, welches anschließend als \textit{Named Export} exportiert wird. Die zweite Kategorie in dieser Arbeit bilden indirekte \textit{Side Effects}. Ein Beipiel dafür ist der Aufruf der Methode \lstinline{incCounter()} in Listing \ref{listing:named_exports_sideeffects_rule_1}. Dieser hat Auswirkungen auf den Export von \lstinline{counter}. Da die Variable \lstinline{counter} nie verwendet oder verändert wird, sind indirekte \textit{Side Effects} wesentlich schwerer zu erkennen als direkte \textit{Side Effects}. 

Für die Erkennung der direkten \textit{Side Effects} werden alle Imports und \textit{Named Exports} in einem Array gespeichert. Dies geschieht mit der Hilfe des \lstinline{ImportDeclaration} und \lstinline{ExportNamedDeclaration} \textit{Node Selectors}. Diese rufen die Funktionen \lstinline{saveImport}  und \lstinline{saveNamedExport} auf. Darin werden die einzelnen \textit{Specifier} in das Array gespeichert. Zum Beispiel bei dem Export \lstinline|export {test1, test2}| werden jeweils die \textit{Specifier Node} \lstinline{test1} und \lstinline{test2} gespeichert. Im nächsten Schritt werden alle \textit{Side Effects} mit dem \lstinline{ExpressionStatement} \textit{Selector} und der Funktion \lstinline{saveExpression} ebenfalls in einem Array abgelegt. Schließlich kann mit dem \textit{Selector} \lstinline{Program:exit} am Ende eines jeden Moduls der Identifier jeder gespeicherten \textit{Expression} mit den \textit{Named Exports} und \textit{Imports} verglichen werden und bei Überschneidungen diese \textit{Expression Node} als \textit{Side Effect} melden.
Somit werden \textit{Side Effects} die direkt einen \textit{Named Export} betreffen erkannt und wird dem Benutzer oder der Benutzerin eine entsprechende Warnung  angezeigt.

Das Erkennen von indirekten \textit{Side Effects} gestaltet sich komplizierter. Zuerst werden alle \textit{Named Imports} wie zum Beispiel \lstinline|import {counter, incCounter} from 'counter'| ebenfalls in einem Array gespeichert. Der dafür verwendete \textit{Node Selector} ist \lstinline{ImportDeclaration}. 
Indirekte \textit{Side Effects} können entstehen wenn Importe mehrere \textit{Specifier} besitzen. Beispiele dafür sind die Import \textit{Specifier} aus Listing \ref{listing:named_exports_sideeffects_rule_1} \lstinline{counter} und \lstinline{incCounter}.Der Import deklariert zwei Variablen aus dem selben Modul. Wenn eine der \textit{Expressions} mit einem der Einträge in \lstinline{import} übereinstimmt und das Modul einen im selben Import befindlichen \textit{Specifier} als \textit{Named Export} exportiert, wird davon ausgegangen, dass es sich dabei um einen \textit{Side Effect} handelt. Die entsprechende \textit{Expression Node} wird somit gemeldet und der Benutzer erhält einen Hinweis, dass dies zu ungewollten Effekten in seinem Programm führen kann.

Indirekte \textit{Side Effects} wie \lstinline{incCounter()} aus Listing \ref{listing:named_exports_sideeffects_rule_1} werden zusätzlich zu den direkten \textit{Side Effects} erkannt und alle Tests werden erfolgreich abgeschlossen.


\subsubsection{Entry Point Side Effects}

\begin{table}[H]
\centering
\caption{Yeoman Generator: Entry Point Side Effects}
\label{tbl:entry_point}
\begin{tabular}{|l|l|}
\hline
Rule-ID: & no-entry-point-sideeffects \\ \hline
Beschreibung: & disallow Side Effects in the Entry Point \\ \hline
\end{tabular}
\end{table}

Die Startdatei oder \textit{Entry Point} einer JavaScript Libary ist ein wichtiger Bestandteil für die Effektivität von \textit{Tree Shaking}. Listing \ref{listing:entry_point_sideeffects_test} zeigt die zum Testen der Regeln implementierten Tests. 

\begin{lstlisting}[
    label=listing:entry_point_sideeffects_test,
	caption=Entry Point Side Effects Unit Tests,
	language=JavaScript,
]
var ruleTester = new RuleTester()
ruleTester.run('entry-point-sideeffects', rule, {
  valid: [
    {
      options: [],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        console.log('sideeffect')
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: []
    },
    {
      options: [],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        module.test = 'tmp'
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: []
    },
    {
      options: [],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        console.log('test')
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: []
    }
  ],

  invalid: [
    {
      options: ['**/src/entry.js'],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        module.test = 'tmp'
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: [
        {
          message: 'Sideeffects in the entry-point are not allowed.',
          type: 'ExpressionStatement'
        }
      ]
    },
    {
      options: ['**/src/entry.js'],
      filename: 'test/usr/src/entry.js',
      code: `
        import module from 'module'
        console.log('test')
        export const export1 = 'export1'
        export default 'default'
      `,
      errors: [
        {
          message: 'Sideeffects in the entry-point are not allowed.',
          type: 'ExpressionStatement'
        }
      ]
    }
  ]
})
\end{lstlisting}

Die Regel soll für jede \textit{Node} im \textit{Entry Point}, bei der es sich weder um einen Import noch einen Export handelt, dem Entwickler und der Entwicklerin eine Meldung anzeigen. Für die Implementierung werden die \textit{Node Types} \lstinline{ImportDeclaration}, \lstinline{ExportNamedDeclaration}, \raggedright\lstinline{ExportDefaultDeclaration}, \lstinline{ExportAllDeclaration} und \lstinline{Program} benötigt. In weiterer Folge wird zusätzlich der \lstinline{:not} \textit{Selector} verwendet. Eine Beschreibung dazu lieferte der ESLint Selector Guide\footnote{https://eslint.org/docs/developer-guide/selectors - besucht am 29.06.2018}. Der \textit{Selector} um alle potenziellen \textit{Side Effects} in einem Modul zu finden ist: \raggedright\lstinline{Program > :not(ImportDeclaration, ExportNamedDeclaration, ExportDefaultDeclaration, ExportAllDeclaration)}.

Anschließend muss noch überprüft werden, ob es sich bei dem aktuellen Modul um den \textit{Entry Point} handelt. Der Benutzer oder die Benutzerin kann dies durch eine Option steuern. Die \textit{Entry Point Side Effects Regel} erwartet als Parameter einen \textit{Glob Pattern String}. Dieser dient dazu den \textit{Entry Point} festzulegen. Nur dieser soll absolut frei von \textit{Side Effects} sein und darf lediglich \lstinline{import} und \lstinline{export} Deklarationen beinhalten.

\subsection{Testen des Plugins}
\label{subsection_testen_des_plugins}

Um die Funktionsweise des Plugins \lstinline{eslint-plugin-treeshaking} zu überprüfen, wird eine Testreihe mit JavaScript Repositories von Github\footnote{https://github.com/ - besucht am 07.07.2018} durchgeführt. Als Test Subjekte werden sowohl Bibliotheken welche \textit{Tree Shaking} unterstützen, als auch Bibliotheken, die nicht darauf optimiert wurden, benötigt. In dem Kapitel \ref{subsubsection:untersuchung_von_js_libs} werden drei Repositories mit der \lstinline{sideEffects: false} Konfiguration ermittelt. Diese werden für die Testreihe erneut verwendet. Die drei nicht in Bezug auf \textit{Tree Shaking} optimierte Bibliotheken werden der selben Liste\footnote{https://www.npmjs.com/browse/depended - besucht am 06.06.2018} entnommen. 

\paragraph{\textit{Tree Shaking} optimiert:}
\begin{itemize}
\item graphql-js\footnote{https://github.com/graphql/graphql-js - besucht am 15.06.2018} 
\item vue\footnote{https://github.com/vuejs/vue - besucht am 15.06.2018} 
\item lodash\footnote{https://github.com/lodash/lodash - besucht am 15.06.2018}
\end{itemize}

\paragraph{kein \textit{Tree Shaking}}
\begin{itemize}
\item d3\footnote{https://github.com/d3/d3 - besucht am 08.07.2018}
\item immutable-js\footnote{https://github.com/facebook/immutable-js - besucht am 08.07.2018}
\item moment\footnote{https://github.com/moment/moment - besucht am 15.06.2018}
\end{itemize}

\subsubsection{Aufbau}

Für die Durchführung der Tests wird von allen Testsubjekten mit dem \lstinline{git clone} Befehl eine lokale Arbeitskopie angelegt. In weitere Folge wird ESLint benötigt. In allen Repositories muss eine statische Code Analyse mit dem \textit{Tree Shaking Plugin} durchgeführt werden. Am besten ist dies mit dem Tool  ESLint-CLI\footnote{https://github.com/eslint/eslint-cli - besucht am 09.07.2018} möglich. Dieses ermöglicht es, die Tests direkt mittels Konsoleneingabe zu starten und wird mit dem Befehl \lstinline{npm install -g eslint-cli} global installiert.

\begin{lstlisting}[
    label=listing:eslintrc,
	caption=Beispiel für eine Test Konfiguration,
	language=JavaScript,
]
{
  "env": {
    "browser": true,
    "es6": true
  },
  "parserOptions": {
    "sourceType": "module"
  },
  "plugins": ["treeshaking"],
  "rules": {
    "treeshaking/no-empty-imports": ["warn",["*.css"]],
    "treeshaking/no-named-exports-sideeffects": "warn",
    "treeshaking/no-entry-point-sideeffects": ["warn", "index.js"]
  }
}
\end{lstlisting}

Für die Konfiguration der Analyse wird eine \lstinline{.eslintrc} Datei verwendet. Listing \ref{listing:eslintrc} zeigt ein Beispiel für diese Datei. Zwischen den verschiedenen Repositories ist es nötig die Optionen bei den drei aktiven Regeln anzupassen.

Eine weitere Abhängigkeit ist das \textit{Tree Shaking Plugin}\footnote{https://github.com/silltho/eslint-plugin-treeshaking}. Dieses wird durch den Befehl \lstinline{npm install git+ssh://git@github.com/silltho/eslint-plugin-treeshaking.git} installiert. Auch ESLint muss als Projektinteres Modul zur Verfügung stehen. Der Befehl \lstinline{npm install eslint} wird also ebenfalls in jedem Repository ausgeführt.

Sollte eine Libary bereits ESLint verwenden, werden alle Abhängigkeiten mit \lstinline{npm install} installiert. Anschließend wird eine Analyse ohne jegliche Anpassungen durchgeführt. Dadurch werden bereits bekannte Warnungen oder Probleme ermittelt und können von den Ergebnissen ausgeschlossen werden. Zuletzt  wird die bereits bestehende Konfiguration um das \textit{Tree Shaking Plugin} und die dazugehörigen drei Regeln erweitert und eine erneute Analyse gestartet.

\subsubsection{Testablauf}

Für den Ablauf wird zuerst der \textit{Entry Point} der zu untersuchenden Bibliothek ermittelt. Der Einstiegspunkt für das Programm wird mit der Option \lstinline{main} in der \lstinline{package.json} Datei gesetzt. Dieser wird als Option für die Regel \lstinline{treeshaking/no-entry-point-sideeffects} benötigt.

Anschließend wird die \lstinline{.eslintrc} Datei, wie in Listing \ref{listing:eslintrc} ersichtlich, erstellt und die Optionen für das jeweilige Repository angepasst.

Darüber hinaus muss ermittelt werden, wo sich die Source Dateien der Bibliotheken befinden. Für den ESLint Befehl wird ein \textit{Glob Pattern} benötigt, welches den gesamten Source Code abdeckt. Schließlich kann die Analyse mit dem Befehl \lstinline{eslint} durchgeführt werden. Für die Ausgabe der Berichte als HTML Datei werden die Optionen \lstinline{-o lint.html} und \lstinline{-f html} verwendet.

Sowohl die projektspezifischen ESLint Optionen, als auch der der Befehl zum durchführen der Tests werden als Tabelle bei den Ergebnissen mit präsentiert. 

\subsubsection{Ergebnisse}

\textbf{graphql-js}
\begin{table}[H]
\centering
\caption{ESLint Optionen für graphql-js}
\label{tbl:graphql-js-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "**/index.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html --rulesdir ./resources/lint}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html --rulesdir ./resources/lint}
\end{center}

GraphQL verwendet bereits ESLint und es existiert im Repository eine \lstinline{.eslintrc} Datei. Durch eine Analyse der in \lstinline{package.json} befindlichen Konfiguration, wird das Script \lstinline{"lint": "eslint --rulesdir ./resources/lint src || (printf '\\033[33mTry: \\033[7m npm run lint -- --fix \\033[0m\\n' && exit 1)"} zur Durchführung einer statischen Analyse verwendet. Die Option \lstinline{--rulesdir ./resources/lint} definiert repositoryspezifische Regeln und muss für den Test adaptiert werden, um Fehler zu vermeiden. Die Konfiguration wurde in den Default Lint Befehl übernommen. Die daraus resultierende HTML Datei zeigt, dass sich keine bekannten Fehler im Repository befinden. Anschließend wurde das \textit{Tree Shaking Plugin} mit den in der Tabelle \ref{tbl:graphql-js-options} ersichtlichen Regeln hinzugefügt. Hier wurde wie erhofft keine Warnung oder Fehler angezeigt. Aus der Sicht des Plugins unterstützt die GraphQl Bibliothek wie erwartet \textit{Tree Shaking}.

\textbf{vue}
\begin{table}[H]
\centering
\caption{ESLint Optionen für vue}
\label{tbl:vue-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "**/src/core/index.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html}
\end{center}

Im Vue Repository befindet sich bereits eine \lstinline{.eslintrc}. Somit muss zuerst ein Lint Bericht ohne dem \textit{Tree Shaking Plugin} erstellt werden. Anders wie bei GraphQl gibt es keine projektspezifische Konfiguration oder Regeln. Für die Erstellung des Prüfberichts musste der \lstinline{eslint} Befehl nicht angepasst werden und \lstinline{default.html} zeigte keine projektinternen Fehler. Darauf folgend wurde das \textit{Tree Shaking Plugin} der Konfiguration hinzugefügt, die Optionen wie in Tabelle \ref{tbl:vue-options} ersichtlich gesetzt und ein neuer Bericht erstellt.

\lstinline{lint.html} zeigt insgesamt 5 Warnungen in der \textit{Entry Point} Datei \lstinline{src/core/index.js}. Alle zeigen dieselbe Nachricht ``Side effects in the entry-point are not allowed.''.

\begin{lstlisting}[
    label=listing:vue_entry_point,
	caption=Vue Entry Point Datei (src/core/index.js),
	language=JavaScript,
]
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
import { isServerRendering } from 'core/util/env'
import { FunctionalRenderContext } from 'core/vdom/create-functional-component'

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

Vue.version = '__VERSION__'

export default Vue
\end{lstlisting}

Listing \ref{listing:vue_entry_point} zeigt die \textit{Entry Point} Datei der Vue Libary. Diese besitzt, wie das \textit{Tree Shaking Plugin} anzeigt, mehrere \textit{Side Effects}. Wenn man den Code betrachtet wird ersichtlich, dass ein \textit{Default Export} und keine \textit{Named Exports} verwendet wird. \textit{Side Effects} werden somit immer inkludiert und stellen keine Gefahr für die Funktionweise des exportierten Objekts dar. Dadurch is es nicht möglich, nur einzelne Teile der Vue Bibliothek zu verwenden. Folgende Fragen bleiben offen: Sollte eine Warnung angezeigt werden, wenn der \textit{Entry Point} nur einen \textit{Default Export} anbietet? Sind \textit{Side Effects} im \textit{Entry Point} erlaubt, wenn nur ein \textit{Default Export} verwendet wird? Weitere Forschung wäre nötig, um diese Fragen zu klären und das Plugin dahingehend zu erweitern. 

\textbf{lodash}
\begin{table}[H]
\centering
\caption{ESLint Optionen für lodash}
\label{tbl:lodash-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "lodash.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint *.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint *.js -o lint.html -f html}
\end{center}

Lodash verwendet ebenso wie GraphQL und Vue ESLint. Beim Erstellen des Prüfberichts werden drei bereits bekannte Fehler angezeigt. \lstinline{Unable to resolve path to module './.internal/createFind.js'.} ist ein Problem beim Auflösen von Dateipfade. Dies wird vorerst ignoriert und wieder wird das \textit{Tree Shaking Plugin} hinzugefügt und die Optionen dem Repository angepasst. Bei der erneuten Durchführung der statischen Analyse werden dieselben drei Fehler wie im Default Bericht angezeigt. Es konnten keine Warnungen in Bezug auf \textit{Tree Shaking} gefunden werden.

\textbf{d3}
\begin{table}[H]
\centering
\caption{ESLint Optionen für d3}
\label{tbl:d3-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "index.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint *.js -o lint_default.html -f html} \linebreak 
\textbf{Lint Befehl:} \lstinline{eslint *.js -o lint.html -f html}
\end{center}

Die d3 Libary ist das erste Testsubjekt, welches nicht die \lstinline{sideEffects} Option in der \lstinline{package.json} Datei verwendet. \textit{Tree Shaking} wurde somit nicht aktiviert und unbenützter Code kann nicht entfernt werden. Das \textit{Tree Shaking Plugin} soll Entwicklern und Entwicklerinnen dabei helfen dies zu ändern und Stellen aufzudecken, bei denen Anpassungen nötig sind. d3 verwendet kein ESLint und besitzt auch keine \lstinline{.eslintrc} Datei. Deshalb wird für den Default Bericht diese Datei erstellt. Listing \ref{listing:eslintrc_d3} zeigt den Inhalt der neuen \lstinline{.eslintrc} Datei.

\begin{lstlisting}[
    label=listing:eslintrc_d3,
	caption=Default Konfiguration für die d3 Bibliothek,
	language=JavaScript,
]
{
  "env": {
    "browser": true,
    "es6": true
  },
  "parserOptions": {
    "sourceType": "module"
  },
  "plugins": [],
  "rules": {}
}
\end{lstlisting}

Der erstellte Bericht zeigt keine Fehler oder Warnungen im Repository. Nach dem Hinzufügen des \textit{Tree Shaking Plugins} und seiner Konfiguration wird ein erneuter \textit{Lint} Bericht \lstinline{lint.html} erstellt. Dieser zeigt ebenso keine Fehler oder Warnungen. Damit sollte die d3 Bibliothek bereits \textit{Tree Shaking} unterstützen. Es fehlt lediglich die \lstinline{sideEffects: false} Einstellung in der \lstinline{package.json} Datei.

\textbf{immutable-js}
\begin{table}[H]
\centering
\caption{ESLint Optionen für immutable-js}
\label{tbl:immutable-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "src/Immutable.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html}
\end{center}

Wie andere Test Subjekten verwendet die Immutable-JS Bibliothek bereits ESLint und besitzt eine Konfigurations Datei. Nachdem Installieren der dafür benötigten Abhängigkeiten wird ein erster \textit{Lint} Bericht, ohne die Verwendung des \textit{Tree Shaking Plugins}, erstellt. Dabei treten weder Warnungen noch Probleme auf. Beim \textit{Linting} mit dem \textit{Tree Shaking Plugin} werden sechs Warnungen in der Date \lstinline{src/CollectionImpl} gefunden. Alle sind vom Typ no-named-exports-sideeffects. Der von der Regel generierte Hinweis lautet: ``Effects on reexported modules (Collection) could be prune by TreeShaking''.

\begin{lstlisting}[
    label=listing:immutable_sideeffects,
	caption=immutable-js Warnungen (src/CollectionImpl),
	language=JavaScript,
]
	import {
		Collection,
		KeyedCollection,
		IndexedCollection,
		SetCollection,
	} from './Collection';

	// Note: all of these methods are deprecated.
	Collection.isIterable = isCollection;
	Collection.isKeyed = isKeyed;
	Collection.isIndexed = isIndexed;
	Collection.isAssociative = isAssociative;
	Collection.isOrdered = isOrdered;

	Collection.Iterator = Iterator;
	
	export {
  		Collection,
  		KeyedCollection,
  		IndexedCollection,
  		SetCollection,
  		CollectionPrototype,
  		IndexedCollectionPrototype,
	};
\end{lstlisting}

Der Programmcode in Listing \ref{listing:immutable_sideeffects} zeigt die von ESLint markierten Zeilen und die dazugehörigen Import und Export Deklarationen. Bei der Verwendung von \textit{Tree Shaking} könnten die Zeilen 9 bis 15 unbeabsichtigt entfernt werden. Weitere Nachforschungen sind nötig,
 um genauer festzustellen ob die vom Plugin, markierten Zeilen auch wirklich zu Fehlern bei der Verwendung von \lstinline{Collection} führen. 

\textbf{moment}
\begin{table}[H]
\centering
\caption{ESLint Optionen für moment}
\label{tbl:moment-options}
\begin{tabular}{|l|l|}
\hline
no-empty-imports             & {[}"warn",{[}{]}{]}         \\ \hline
no-named-exports-sideeffects & "warn"                      \\ \hline
no-entry-point-sideeffects   & {[}"warn", "src/moment.js"{]} \\ \hline
\end{tabular}
\end{table}

\begin{center}
\textbf{Default Lint Befehl:} \lstinline{eslint src/**/*.js -o lint_default.html -f html}\linebreak 
\textbf{Lint Befehl:} \lstinline{eslint src/**/*.js -o lint.html -f html}
\end{center}

moment-js ist die letzte Javascript Bliobliothek die für die Überprüfung des \textit{Tree Shaking Plugins} untersucht wird. Ebenso wie d3 und immutable-js ermöglicht sie kein \textit{Tree Shaking}. Für die Entwicklung wurde nicht ESLint verwendet. Somit wird eine \lstinline{.eslintrc} Datei ohne aktivierte Regeln erstellt und eine Analyse damit durchgeführt. Der resultierende Bericht zeigt keine Fehler  in den Source Dateien. Nach dem Hinzufügen der \textit{Tree Shaking Regeln} wie in Tabelle \ref{tbl:moment-options} gezeigt, werden im Bericht insgesamt 19 Warnungen angezeigt. Diese betreffen vier Dateien und sind vom Typ no-empty-imports.

Die vier betroffenen Dateien sind:
\begin{itemize}
\item src/lib/duration/duration.js
\item src/lib/locale/en.js
\item src/lib/locale/locale.js
\item src/lib/units/units.js
\end{itemize}

\begin{lstlisting}[
    label=listing:moment_sideeffects,
	caption=moment Datei mit Warnungen (src/lib/duration/duration.js),
	language=JavaScript,
]
	import {
		Collection,
		KeyedCollection,
		IndexedCollection,
		SetCollection,
	} from './Collection';

	// Side effect imports
	import './prototype';

	import { createDuration } from './create';
	import { isDuration } from './constructor';
	import {
    		getSetRelativeTimeRounding,
    		getSetRelativeTimeThreshold
	} from './humanize';

	export {
    		createDuration,
    		isDuration,
    		getSetRelativeTimeRounding,
    		getSetRelativeTimeThreshold
	};
\end{lstlisting}

Listing \ref{listing:moment_sideeffects} zeigt in Zeile 9 einen \textit{Empty Import}, der die Warnung in dieser Datei verursacht. Er wurde bereits vorab von einem Entwickler oder einer Entwicklerin als \textit{Side Effect} makiert. Die genauen Fehlermeldungen des \textit{Tree Shaking Plugins} für diese Zeile lauten:``empty imports are removed by tree shaking. Make sure you add ./prototype to package.json sideEffects option''. Durch die Verwendung eines Arrays von Strings statt false für die \lstinline{sideEffects} Konfiguration, kann Webpack informiert werden, diese Datei auf jeden Fall einzubinden. Die dafür nötige Einstellung wäre \lstinline{sideEffects: ['prototype']}. Die no-empty-imports Regel bietet an, dies durch eine Option zu konfigurieren. Es wird daher der Eintrag für no-empty-imports in der \lstinline{.eslintrc} Datei zu \lstinline{"treeshaking/no-empty-imports": ["warn", ["prototype"]]} angepasst. Ein erneuter Bericht wird erstellt und dieser zeigt die Warnung in der Datei aus Listing \ref{listing:moment_sideeffects} nicht an. Wiederum wären weitere Forschungen nötig, um die richtige Funktionsweise von \textit{Tree Shaking} an dieser Stelle genauer zu evaluieren.

\section{Ausblick auf zukünftige Arbeiten}

Als Teil dieser Arbeit wurden im Kapitel \ref{subsubsection:best_practices} vier Annahmen zur Vermeidung von \textit{Side Effects} getroffen. Diese konnten durch eine Literatur Analyse und Unteruchung von GitHub Repositories ausgearbeitet werden. Nachfolgende Forschung mit mehr Untersuchungsobjekten und einer größeren Testreihe könnte weitere Erkenntnisse zur Vermeidung von \textit{Side Effects} liefern. Dies kann zur Implementierung weiterer Regeln oder einer Anpassung der bereits existierenden Regeln führen.

Ein weiterer Aspekt ist die Erweiterung des \textit{Tree Shaking Plugins} auf weitere ECMAScript Versionen. Diese Arbeit konzentriert sich auf die Verwendung von ECMAScript 2015. Mit ECMAScript 2016\footnote{https://www.ecma-international.org/ecma-262/7.0/ - besucht am 13.07.2018} und ECMAScript 2017\footnote{https://www.ecma-international.org/ecma-262/8.0/ - besucht am 13.07.2018} existieren bereits nachfolgende Spezifikationen. Vielmehr wäre auch die Verwendung verschiedener \textit{Bundler} weitere Untersuchungen wert. RollupJS ist eine Alternative zu Webpack. Auf dessen Verwendung spezialisiert sich diese Arbeit.

Zuletzt könnten zukünftige Arbeiten das Erstellen von \textit{Fixes} für die Regeln des \textit{Tree Shaking Plugins} untersuchen. \textit{Fixes} bieten die Möglichkeit, Fehler oder Warnungen automatisiert zu reparieren, ohne Eingreifen eines Entwicklers oder einer Entwicklerin. In weiterer Folge sind \textit{Fixes} ein wichtiges Feature, um Entwickler und Entwicklerinnen zu entlasten. Im Zusammenhang mit \textit{Tree Shaking} und dem in dieser Arbeit erstellten Plugin, wäre zuerst zu ntersuchen ob, eine automatisierte Lösung möglich ist und wie diese zu implementieren wäre.

\section{Schlussfolgerung}

Ziel dieser Arbeit ist es, für Entwickler und Entwicklerinnen im JavaScript Bereich ein Werkzeug anzubieten, welches dabei hilft ihren Sourcecode dahingehend zu gestalten, um \textit{Tree Shaking} zu ermöglichen. Dies führt zu einer Reduktion der an die Benutzer und Benutzerinnen gesendeten Daten, verringert die Ladezeit und hat somit einen positiv Einfluss auf die \textit{User Experience}.

Um \textit{Tree Shaking} von JavaScript zu ermöglichen ist ein \textit{Static Module Bundler} wie Webpack und die Verwendung der ECMAScript 6 Spezifikationen nötig. Im Gegensatz zu CommonJS oder der Asynchronous Model Definition bietet die statische Struktur von ES6 Modulen die Möglichkeit, diese mit einer statischen Analyse zu untersuchen, bevor sie von einem \textit{Bundler} evaluiert und in einer Datei kombiniert werden.

Die Herausforderungen beim \textit{Tree Shaking} wurden durch eine Literatur Recherche und der Untersuchung von Projekten auf GitHub, welche dieses bereits implementieren ermittelt. Daraus resultierte die Erkenntnis, dass für eine fehlerlose Funktionweise von \textit{Tree Shaking} sogenannte \textit{Side Effects} ein wichtiger Faktor sind. Im Zuge dessen wurden mehrere Best Practices und Code Smells für den Umgang mit \textit{Side Effects} ermittelt:

\begin{itemize}
\item Bei der Vewendung von \textit{Named Exports} ist auf \textit{Side Effects} im Modul zu achten.
\item \textit{Side Effects} wirken sich nicht auf den \textit{Default Export} aus.
\item Alle \textit{Empty Imports} müssen dem \textit{Bundler} mit Hilfe der \lstinline{sideEffects} \textit{Property} mitgeteilt werden.
\item Der \textit{Entry Point} eines Projektes sollte keine  \textit{Side Effects} implementieren.
\end{itemize}

Im Anschluss wurden diese Informationen verwendet um ein Plugin für ESLint zu erstellen. ESLint ermöglicht die statische Analyse von JavaScript Code und bietet durch Plugins eine einfache und gut dokumentierte Lösung um diese zu erweitern. In weiterer Folge wurde das Plugin \textit{eslint-plugin-treeshaking} erstellt und drei Regeln zur Vermeidung von Code Smells implementiert.

Abschließend wurden sechs Projekte auf GitHub ausgewählt, um die Funktionweise des Plugins zu überprüfen. Drei davon wurden bereits auf \textit{Tree Shaking} optimiert und bei der Analyse der Bibliothek Vue konnte eine Schwierigkeit in Bezug auf \textit{Default Exports} erkannt werden. Bei den beiden anderen Repositories konnten keine Fehler oder Warnungen vom \textit{Tree Shaking Plugin} ermittelt werden.

Weitere wichtige Erkenntnisse konnten durch die Überprüfung der drei Repositories erlangt werden, welche kein \textit{Tree Shaking} unterstützen. Die JavaScript Libary d3 besitzt eine sehr modulare Architektur und kann \textit{Tree Shaking} ohne Anpassungen unterstützen. Bei den beiden anderen Test Subjekten konnten Probleme ermittelt werden, welche zu unerwünschten Nebeneffekten durch \textit{Tree Shaking} führen können.

Die durchgeführten Tests bestätigen den positiven Nutzen der statischen Analyse in Verbindung mit dem \textit{Tree Shaking Plugins} für Entwickler und Entwicklerinnen. Es werden Code Segmente die beim \textit{Tree Shaking} zu Problemen führen können angezeigt. Die sofortige Rückmeldung erleichtert das Lösen von Fehlern wärend der Entwicklung. Vielmehr kann das Plugin auch dazu beitragen nachträglich JavaScript Code zu optimieren, um \textit{Tree Shaking} zu ermöglichen.